
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Regiao
 * 
 */
export type Regiao = $Result.DefaultSelection<Prisma.$RegiaoPayload>
/**
 * Model Grupo
 * 
 */
export type Grupo = $Result.DefaultSelection<Prisma.$GrupoPayload>
/**
 * Model Escola
 * 
 */
export type Escola = $Result.DefaultSelection<Prisma.$EscolaPayload>
/**
 * Model EscolaUsuario
 * 
 */
export type EscolaUsuario = $Result.DefaultSelection<Prisma.$EscolaUsuarioPayload>
/**
 * Model AnoEscolar
 * 
 */
export type AnoEscolar = $Result.DefaultSelection<Prisma.$AnoEscolarPayload>
/**
 * Model Turma
 * 
 */
export type Turma = $Result.DefaultSelection<Prisma.$TurmaPayload>
/**
 * Model Aluno
 * 
 */
export type Aluno = $Result.DefaultSelection<Prisma.$AlunoPayload>
/**
 * Model EventoAvaliacao
 * 
 */
export type EventoAvaliacao = $Result.DefaultSelection<Prisma.$EventoAvaliacaoPayload>
/**
 * Model Avaliacao
 * 
 */
export type Avaliacao = $Result.DefaultSelection<Prisma.$AvaliacaoPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.regiao`: Exposes CRUD operations for the **Regiao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regiaos
    * const regiaos = await prisma.regiao.findMany()
    * ```
    */
  get regiao(): Prisma.RegiaoDelegate<ExtArgs>;

  /**
   * `prisma.grupo`: Exposes CRUD operations for the **Grupo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grupos
    * const grupos = await prisma.grupo.findMany()
    * ```
    */
  get grupo(): Prisma.GrupoDelegate<ExtArgs>;

  /**
   * `prisma.escola`: Exposes CRUD operations for the **Escola** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escolas
    * const escolas = await prisma.escola.findMany()
    * ```
    */
  get escola(): Prisma.EscolaDelegate<ExtArgs>;

  /**
   * `prisma.escolaUsuario`: Exposes CRUD operations for the **EscolaUsuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscolaUsuarios
    * const escolaUsuarios = await prisma.escolaUsuario.findMany()
    * ```
    */
  get escolaUsuario(): Prisma.EscolaUsuarioDelegate<ExtArgs>;

  /**
   * `prisma.anoEscolar`: Exposes CRUD operations for the **AnoEscolar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnoEscolars
    * const anoEscolars = await prisma.anoEscolar.findMany()
    * ```
    */
  get anoEscolar(): Prisma.AnoEscolarDelegate<ExtArgs>;

  /**
   * `prisma.turma`: Exposes CRUD operations for the **Turma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Turmas
    * const turmas = await prisma.turma.findMany()
    * ```
    */
  get turma(): Prisma.TurmaDelegate<ExtArgs>;

  /**
   * `prisma.aluno`: Exposes CRUD operations for the **Aluno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alunos
    * const alunos = await prisma.aluno.findMany()
    * ```
    */
  get aluno(): Prisma.AlunoDelegate<ExtArgs>;

  /**
   * `prisma.eventoAvaliacao`: Exposes CRUD operations for the **EventoAvaliacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventoAvaliacaos
    * const eventoAvaliacaos = await prisma.eventoAvaliacao.findMany()
    * ```
    */
  get eventoAvaliacao(): Prisma.EventoAvaliacaoDelegate<ExtArgs>;

  /**
   * `prisma.avaliacao`: Exposes CRUD operations for the **Avaliacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avaliacaos
    * const avaliacaos = await prisma.avaliacao.findMany()
    * ```
    */
  get avaliacao(): Prisma.AvaliacaoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Regiao: 'Regiao',
    Grupo: 'Grupo',
    Escola: 'Escola',
    EscolaUsuario: 'EscolaUsuario',
    AnoEscolar: 'AnoEscolar',
    Turma: 'Turma',
    Aluno: 'Aluno',
    EventoAvaliacao: 'EventoAvaliacao',
    Avaliacao: 'Avaliacao'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "regiao" | "grupo" | "escola" | "escolaUsuario" | "anoEscolar" | "turma" | "aluno" | "eventoAvaliacao" | "avaliacao"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Regiao: {
        payload: Prisma.$RegiaoPayload<ExtArgs>
        fields: Prisma.RegiaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegiaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegiaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload>
          }
          findFirst: {
            args: Prisma.RegiaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegiaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload>
          }
          findMany: {
            args: Prisma.RegiaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload>[]
          }
          create: {
            args: Prisma.RegiaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload>
          }
          createMany: {
            args: Prisma.RegiaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegiaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload>[]
          }
          delete: {
            args: Prisma.RegiaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload>
          }
          update: {
            args: Prisma.RegiaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload>
          }
          deleteMany: {
            args: Prisma.RegiaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegiaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegiaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegiaoPayload>
          }
          aggregate: {
            args: Prisma.RegiaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegiao>
          }
          groupBy: {
            args: Prisma.RegiaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegiaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegiaoCountArgs<ExtArgs>
            result: $Utils.Optional<RegiaoCountAggregateOutputType> | number
          }
        }
      }
      Grupo: {
        payload: Prisma.$GrupoPayload<ExtArgs>
        fields: Prisma.GrupoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GrupoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GrupoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          findFirst: {
            args: Prisma.GrupoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GrupoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          findMany: {
            args: Prisma.GrupoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>[]
          }
          create: {
            args: Prisma.GrupoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          createMany: {
            args: Prisma.GrupoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GrupoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>[]
          }
          delete: {
            args: Prisma.GrupoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          update: {
            args: Prisma.GrupoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          deleteMany: {
            args: Prisma.GrupoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GrupoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GrupoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrupoPayload>
          }
          aggregate: {
            args: Prisma.GrupoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrupo>
          }
          groupBy: {
            args: Prisma.GrupoGroupByArgs<ExtArgs>
            result: $Utils.Optional<GrupoGroupByOutputType>[]
          }
          count: {
            args: Prisma.GrupoCountArgs<ExtArgs>
            result: $Utils.Optional<GrupoCountAggregateOutputType> | number
          }
        }
      }
      Escola: {
        payload: Prisma.$EscolaPayload<ExtArgs>
        fields: Prisma.EscolaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscolaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscolaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          findFirst: {
            args: Prisma.EscolaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscolaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          findMany: {
            args: Prisma.EscolaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>[]
          }
          create: {
            args: Prisma.EscolaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          createMany: {
            args: Prisma.EscolaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscolaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>[]
          }
          delete: {
            args: Prisma.EscolaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          update: {
            args: Prisma.EscolaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          deleteMany: {
            args: Prisma.EscolaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscolaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscolaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          aggregate: {
            args: Prisma.EscolaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscola>
          }
          groupBy: {
            args: Prisma.EscolaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscolaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscolaCountArgs<ExtArgs>
            result: $Utils.Optional<EscolaCountAggregateOutputType> | number
          }
        }
      }
      EscolaUsuario: {
        payload: Prisma.$EscolaUsuarioPayload<ExtArgs>
        fields: Prisma.EscolaUsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscolaUsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscolaUsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload>
          }
          findFirst: {
            args: Prisma.EscolaUsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscolaUsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload>
          }
          findMany: {
            args: Prisma.EscolaUsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload>[]
          }
          create: {
            args: Prisma.EscolaUsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload>
          }
          createMany: {
            args: Prisma.EscolaUsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscolaUsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload>[]
          }
          delete: {
            args: Prisma.EscolaUsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload>
          }
          update: {
            args: Prisma.EscolaUsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload>
          }
          deleteMany: {
            args: Prisma.EscolaUsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscolaUsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EscolaUsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaUsuarioPayload>
          }
          aggregate: {
            args: Prisma.EscolaUsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscolaUsuario>
          }
          groupBy: {
            args: Prisma.EscolaUsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscolaUsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscolaUsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<EscolaUsuarioCountAggregateOutputType> | number
          }
        }
      }
      AnoEscolar: {
        payload: Prisma.$AnoEscolarPayload<ExtArgs>
        fields: Prisma.AnoEscolarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnoEscolarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnoEscolarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload>
          }
          findFirst: {
            args: Prisma.AnoEscolarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnoEscolarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload>
          }
          findMany: {
            args: Prisma.AnoEscolarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload>[]
          }
          create: {
            args: Prisma.AnoEscolarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload>
          }
          createMany: {
            args: Prisma.AnoEscolarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnoEscolarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload>[]
          }
          delete: {
            args: Prisma.AnoEscolarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload>
          }
          update: {
            args: Prisma.AnoEscolarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload>
          }
          deleteMany: {
            args: Prisma.AnoEscolarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnoEscolarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnoEscolarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnoEscolarPayload>
          }
          aggregate: {
            args: Prisma.AnoEscolarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnoEscolar>
          }
          groupBy: {
            args: Prisma.AnoEscolarGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnoEscolarGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnoEscolarCountArgs<ExtArgs>
            result: $Utils.Optional<AnoEscolarCountAggregateOutputType> | number
          }
        }
      }
      Turma: {
        payload: Prisma.$TurmaPayload<ExtArgs>
        fields: Prisma.TurmaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TurmaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TurmaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          findFirst: {
            args: Prisma.TurmaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TurmaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          findMany: {
            args: Prisma.TurmaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>[]
          }
          create: {
            args: Prisma.TurmaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          createMany: {
            args: Prisma.TurmaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TurmaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>[]
          }
          delete: {
            args: Prisma.TurmaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          update: {
            args: Prisma.TurmaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          deleteMany: {
            args: Prisma.TurmaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TurmaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TurmaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          aggregate: {
            args: Prisma.TurmaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTurma>
          }
          groupBy: {
            args: Prisma.TurmaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TurmaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TurmaCountArgs<ExtArgs>
            result: $Utils.Optional<TurmaCountAggregateOutputType> | number
          }
        }
      }
      Aluno: {
        payload: Prisma.$AlunoPayload<ExtArgs>
        fields: Prisma.AlunoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlunoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlunoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          findFirst: {
            args: Prisma.AlunoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlunoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          findMany: {
            args: Prisma.AlunoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>[]
          }
          create: {
            args: Prisma.AlunoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          createMany: {
            args: Prisma.AlunoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlunoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>[]
          }
          delete: {
            args: Prisma.AlunoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          update: {
            args: Prisma.AlunoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          deleteMany: {
            args: Prisma.AlunoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlunoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlunoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          aggregate: {
            args: Prisma.AlunoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAluno>
          }
          groupBy: {
            args: Prisma.AlunoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlunoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlunoCountArgs<ExtArgs>
            result: $Utils.Optional<AlunoCountAggregateOutputType> | number
          }
        }
      }
      EventoAvaliacao: {
        payload: Prisma.$EventoAvaliacaoPayload<ExtArgs>
        fields: Prisma.EventoAvaliacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventoAvaliacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventoAvaliacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload>
          }
          findFirst: {
            args: Prisma.EventoAvaliacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventoAvaliacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload>
          }
          findMany: {
            args: Prisma.EventoAvaliacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload>[]
          }
          create: {
            args: Prisma.EventoAvaliacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload>
          }
          createMany: {
            args: Prisma.EventoAvaliacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventoAvaliacaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload>[]
          }
          delete: {
            args: Prisma.EventoAvaliacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload>
          }
          update: {
            args: Prisma.EventoAvaliacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload>
          }
          deleteMany: {
            args: Prisma.EventoAvaliacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventoAvaliacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventoAvaliacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAvaliacaoPayload>
          }
          aggregate: {
            args: Prisma.EventoAvaliacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventoAvaliacao>
          }
          groupBy: {
            args: Prisma.EventoAvaliacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventoAvaliacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventoAvaliacaoCountArgs<ExtArgs>
            result: $Utils.Optional<EventoAvaliacaoCountAggregateOutputType> | number
          }
        }
      }
      Avaliacao: {
        payload: Prisma.$AvaliacaoPayload<ExtArgs>
        fields: Prisma.AvaliacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvaliacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvaliacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          findFirst: {
            args: Prisma.AvaliacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvaliacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          findMany: {
            args: Prisma.AvaliacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          create: {
            args: Prisma.AvaliacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          createMany: {
            args: Prisma.AvaliacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvaliacaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          delete: {
            args: Prisma.AvaliacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          update: {
            args: Prisma.AvaliacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          deleteMany: {
            args: Prisma.AvaliacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvaliacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AvaliacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          aggregate: {
            args: Prisma.AvaliacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvaliacao>
          }
          groupBy: {
            args: Prisma.AvaliacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvaliacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvaliacaoCountArgs<ExtArgs>
            result: $Utils.Optional<AvaliacaoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    escolas: number
    avaliacoesAplicadas: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escolas?: boolean | UsuarioCountOutputTypeCountEscolasArgs
    avaliacoesAplicadas?: boolean | UsuarioCountOutputTypeCountAvaliacoesAplicadasArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEscolasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscolaUsuarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAvaliacoesAplicadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }


  /**
   * Count Type RegiaoCountOutputType
   */

  export type RegiaoCountOutputType = {
    escolas: number
  }

  export type RegiaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escolas?: boolean | RegiaoCountOutputTypeCountEscolasArgs
  }

  // Custom InputTypes
  /**
   * RegiaoCountOutputType without action
   */
  export type RegiaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegiaoCountOutputType
     */
    select?: RegiaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegiaoCountOutputType without action
   */
  export type RegiaoCountOutputTypeCountEscolasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscolaWhereInput
  }


  /**
   * Count Type GrupoCountOutputType
   */

  export type GrupoCountOutputType = {
    escolas: number
  }

  export type GrupoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escolas?: boolean | GrupoCountOutputTypeCountEscolasArgs
  }

  // Custom InputTypes
  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrupoCountOutputType
     */
    select?: GrupoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeCountEscolasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscolaWhereInput
  }


  /**
   * Count Type EscolaCountOutputType
   */

  export type EscolaCountOutputType = {
    turmas: number
    usuarios: number
  }

  export type EscolaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    turmas?: boolean | EscolaCountOutputTypeCountTurmasArgs
    usuarios?: boolean | EscolaCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * EscolaCountOutputType without action
   */
  export type EscolaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaCountOutputType
     */
    select?: EscolaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EscolaCountOutputType without action
   */
  export type EscolaCountOutputTypeCountTurmasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TurmaWhereInput
  }

  /**
   * EscolaCountOutputType without action
   */
  export type EscolaCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscolaUsuarioWhereInput
  }


  /**
   * Count Type AnoEscolarCountOutputType
   */

  export type AnoEscolarCountOutputType = {
    turmas: number
  }

  export type AnoEscolarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    turmas?: boolean | AnoEscolarCountOutputTypeCountTurmasArgs
  }

  // Custom InputTypes
  /**
   * AnoEscolarCountOutputType without action
   */
  export type AnoEscolarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolarCountOutputType
     */
    select?: AnoEscolarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnoEscolarCountOutputType without action
   */
  export type AnoEscolarCountOutputTypeCountTurmasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TurmaWhereInput
  }


  /**
   * Count Type TurmaCountOutputType
   */

  export type TurmaCountOutputType = {
    alunos: number
  }

  export type TurmaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alunos?: boolean | TurmaCountOutputTypeCountAlunosArgs
  }

  // Custom InputTypes
  /**
   * TurmaCountOutputType without action
   */
  export type TurmaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TurmaCountOutputType
     */
    select?: TurmaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TurmaCountOutputType without action
   */
  export type TurmaCountOutputTypeCountAlunosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlunoWhereInput
  }


  /**
   * Count Type AlunoCountOutputType
   */

  export type AlunoCountOutputType = {
    avaliacoes: number
  }

  export type AlunoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avaliacoes?: boolean | AlunoCountOutputTypeCountAvaliacoesArgs
  }

  // Custom InputTypes
  /**
   * AlunoCountOutputType without action
   */
  export type AlunoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlunoCountOutputType
     */
    select?: AlunoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlunoCountOutputType without action
   */
  export type AlunoCountOutputTypeCountAvaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }


  /**
   * Count Type EventoAvaliacaoCountOutputType
   */

  export type EventoAvaliacaoCountOutputType = {
    avaliacoes: number
  }

  export type EventoAvaliacaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avaliacoes?: boolean | EventoAvaliacaoCountOutputTypeCountAvaliacoesArgs
  }

  // Custom InputTypes
  /**
   * EventoAvaliacaoCountOutputType without action
   */
  export type EventoAvaliacaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacaoCountOutputType
     */
    select?: EventoAvaliacaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventoAvaliacaoCountOutputType without action
   */
  export type EventoAvaliacaoCountOutputTypeCountAvaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    tipo: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    tipo: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    tipo: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    tipo?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    tipo?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    tipo?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nome: string
    email: string
    senha: string
    tipo: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    tipo?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    escolas?: boolean | Usuario$escolasArgs<ExtArgs>
    avaliacoesAplicadas?: boolean | Usuario$avaliacoesAplicadasArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    tipo?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    tipo?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escolas?: boolean | Usuario$escolasArgs<ExtArgs>
    avaliacoesAplicadas?: boolean | Usuario$avaliacoesAplicadasArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      escolas: Prisma.$EscolaUsuarioPayload<ExtArgs>[]
      avaliacoesAplicadas: Prisma.$AvaliacaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      email: string
      senha: string
      tipo: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    escolas<T extends Usuario$escolasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$escolasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    avaliacoesAplicadas<T extends Usuario$avaliacoesAplicadasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$avaliacoesAplicadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nome: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
    readonly tipo: FieldRef<"Usuario", 'String'>
    readonly ativo: FieldRef<"Usuario", 'Boolean'>
    readonly criadoEm: FieldRef<"Usuario", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.escolas
   */
  export type Usuario$escolasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    where?: EscolaUsuarioWhereInput
    orderBy?: EscolaUsuarioOrderByWithRelationInput | EscolaUsuarioOrderByWithRelationInput[]
    cursor?: EscolaUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscolaUsuarioScalarFieldEnum | EscolaUsuarioScalarFieldEnum[]
  }

  /**
   * Usuario.avaliacoesAplicadas
   */
  export type Usuario$avaliacoesAplicadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Regiao
   */

  export type AggregateRegiao = {
    _count: RegiaoCountAggregateOutputType | null
    _avg: RegiaoAvgAggregateOutputType | null
    _sum: RegiaoSumAggregateOutputType | null
    _min: RegiaoMinAggregateOutputType | null
    _max: RegiaoMaxAggregateOutputType | null
  }

  export type RegiaoAvgAggregateOutputType = {
    id: number | null
  }

  export type RegiaoSumAggregateOutputType = {
    id: number | null
  }

  export type RegiaoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type RegiaoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type RegiaoCountAggregateOutputType = {
    id: number
    nome: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type RegiaoAvgAggregateInputType = {
    id?: true
  }

  export type RegiaoSumAggregateInputType = {
    id?: true
  }

  export type RegiaoMinAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type RegiaoMaxAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type RegiaoCountAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type RegiaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regiao to aggregate.
     */
    where?: RegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regiaos to fetch.
     */
    orderBy?: RegiaoOrderByWithRelationInput | RegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regiaos
    **/
    _count?: true | RegiaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegiaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegiaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegiaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegiaoMaxAggregateInputType
  }

  export type GetRegiaoAggregateType<T extends RegiaoAggregateArgs> = {
        [P in keyof T & keyof AggregateRegiao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegiao[P]>
      : GetScalarType<T[P], AggregateRegiao[P]>
  }




  export type RegiaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegiaoWhereInput
    orderBy?: RegiaoOrderByWithAggregationInput | RegiaoOrderByWithAggregationInput[]
    by: RegiaoScalarFieldEnum[] | RegiaoScalarFieldEnum
    having?: RegiaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegiaoCountAggregateInputType | true
    _avg?: RegiaoAvgAggregateInputType
    _sum?: RegiaoSumAggregateInputType
    _min?: RegiaoMinAggregateInputType
    _max?: RegiaoMaxAggregateInputType
  }

  export type RegiaoGroupByOutputType = {
    id: number
    nome: string
    criadoEm: Date
    atualizadoEm: Date
    _count: RegiaoCountAggregateOutputType | null
    _avg: RegiaoAvgAggregateOutputType | null
    _sum: RegiaoSumAggregateOutputType | null
    _min: RegiaoMinAggregateOutputType | null
    _max: RegiaoMaxAggregateOutputType | null
  }

  type GetRegiaoGroupByPayload<T extends RegiaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegiaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegiaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegiaoGroupByOutputType[P]>
            : GetScalarType<T[P], RegiaoGroupByOutputType[P]>
        }
      >
    >


  export type RegiaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    escolas?: boolean | Regiao$escolasArgs<ExtArgs>
    _count?: boolean | RegiaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regiao"]>

  export type RegiaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["regiao"]>

  export type RegiaoSelectScalar = {
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type RegiaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escolas?: boolean | Regiao$escolasArgs<ExtArgs>
    _count?: boolean | RegiaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegiaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegiaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Regiao"
    objects: {
      escolas: Prisma.$EscolaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["regiao"]>
    composites: {}
  }

  type RegiaoGetPayload<S extends boolean | null | undefined | RegiaoDefaultArgs> = $Result.GetResult<Prisma.$RegiaoPayload, S>

  type RegiaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegiaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RegiaoCountAggregateInputType | true
    }

  export interface RegiaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Regiao'], meta: { name: 'Regiao' } }
    /**
     * Find zero or one Regiao that matches the filter.
     * @param {RegiaoFindUniqueArgs} args - Arguments to find a Regiao
     * @example
     * // Get one Regiao
     * const regiao = await prisma.regiao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegiaoFindUniqueArgs>(args: SelectSubset<T, RegiaoFindUniqueArgs<ExtArgs>>): Prisma__RegiaoClient<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Regiao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RegiaoFindUniqueOrThrowArgs} args - Arguments to find a Regiao
     * @example
     * // Get one Regiao
     * const regiao = await prisma.regiao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegiaoFindUniqueOrThrowArgs>(args: SelectSubset<T, RegiaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegiaoClient<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Regiao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegiaoFindFirstArgs} args - Arguments to find a Regiao
     * @example
     * // Get one Regiao
     * const regiao = await prisma.regiao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegiaoFindFirstArgs>(args?: SelectSubset<T, RegiaoFindFirstArgs<ExtArgs>>): Prisma__RegiaoClient<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Regiao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegiaoFindFirstOrThrowArgs} args - Arguments to find a Regiao
     * @example
     * // Get one Regiao
     * const regiao = await prisma.regiao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegiaoFindFirstOrThrowArgs>(args?: SelectSubset<T, RegiaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegiaoClient<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Regiaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegiaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regiaos
     * const regiaos = await prisma.regiao.findMany()
     * 
     * // Get first 10 Regiaos
     * const regiaos = await prisma.regiao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regiaoWithIdOnly = await prisma.regiao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegiaoFindManyArgs>(args?: SelectSubset<T, RegiaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Regiao.
     * @param {RegiaoCreateArgs} args - Arguments to create a Regiao.
     * @example
     * // Create one Regiao
     * const Regiao = await prisma.regiao.create({
     *   data: {
     *     // ... data to create a Regiao
     *   }
     * })
     * 
     */
    create<T extends RegiaoCreateArgs>(args: SelectSubset<T, RegiaoCreateArgs<ExtArgs>>): Prisma__RegiaoClient<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Regiaos.
     * @param {RegiaoCreateManyArgs} args - Arguments to create many Regiaos.
     * @example
     * // Create many Regiaos
     * const regiao = await prisma.regiao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegiaoCreateManyArgs>(args?: SelectSubset<T, RegiaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regiaos and returns the data saved in the database.
     * @param {RegiaoCreateManyAndReturnArgs} args - Arguments to create many Regiaos.
     * @example
     * // Create many Regiaos
     * const regiao = await prisma.regiao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regiaos and only return the `id`
     * const regiaoWithIdOnly = await prisma.regiao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegiaoCreateManyAndReturnArgs>(args?: SelectSubset<T, RegiaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Regiao.
     * @param {RegiaoDeleteArgs} args - Arguments to delete one Regiao.
     * @example
     * // Delete one Regiao
     * const Regiao = await prisma.regiao.delete({
     *   where: {
     *     // ... filter to delete one Regiao
     *   }
     * })
     * 
     */
    delete<T extends RegiaoDeleteArgs>(args: SelectSubset<T, RegiaoDeleteArgs<ExtArgs>>): Prisma__RegiaoClient<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Regiao.
     * @param {RegiaoUpdateArgs} args - Arguments to update one Regiao.
     * @example
     * // Update one Regiao
     * const regiao = await prisma.regiao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegiaoUpdateArgs>(args: SelectSubset<T, RegiaoUpdateArgs<ExtArgs>>): Prisma__RegiaoClient<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Regiaos.
     * @param {RegiaoDeleteManyArgs} args - Arguments to filter Regiaos to delete.
     * @example
     * // Delete a few Regiaos
     * const { count } = await prisma.regiao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegiaoDeleteManyArgs>(args?: SelectSubset<T, RegiaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegiaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regiaos
     * const regiao = await prisma.regiao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegiaoUpdateManyArgs>(args: SelectSubset<T, RegiaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Regiao.
     * @param {RegiaoUpsertArgs} args - Arguments to update or create a Regiao.
     * @example
     * // Update or create a Regiao
     * const regiao = await prisma.regiao.upsert({
     *   create: {
     *     // ... data to create a Regiao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regiao we want to update
     *   }
     * })
     */
    upsert<T extends RegiaoUpsertArgs>(args: SelectSubset<T, RegiaoUpsertArgs<ExtArgs>>): Prisma__RegiaoClient<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Regiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegiaoCountArgs} args - Arguments to filter Regiaos to count.
     * @example
     * // Count the number of Regiaos
     * const count = await prisma.regiao.count({
     *   where: {
     *     // ... the filter for the Regiaos we want to count
     *   }
     * })
    **/
    count<T extends RegiaoCountArgs>(
      args?: Subset<T, RegiaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegiaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegiaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegiaoAggregateArgs>(args: Subset<T, RegiaoAggregateArgs>): Prisma.PrismaPromise<GetRegiaoAggregateType<T>>

    /**
     * Group by Regiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegiaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegiaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegiaoGroupByArgs['orderBy'] }
        : { orderBy?: RegiaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegiaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegiaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Regiao model
   */
  readonly fields: RegiaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Regiao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegiaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    escolas<T extends Regiao$escolasArgs<ExtArgs> = {}>(args?: Subset<T, Regiao$escolasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Regiao model
   */ 
  interface RegiaoFieldRefs {
    readonly id: FieldRef<"Regiao", 'Int'>
    readonly nome: FieldRef<"Regiao", 'String'>
    readonly criadoEm: FieldRef<"Regiao", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Regiao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Regiao findUnique
   */
  export type RegiaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
    /**
     * Filter, which Regiao to fetch.
     */
    where: RegiaoWhereUniqueInput
  }

  /**
   * Regiao findUniqueOrThrow
   */
  export type RegiaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
    /**
     * Filter, which Regiao to fetch.
     */
    where: RegiaoWhereUniqueInput
  }

  /**
   * Regiao findFirst
   */
  export type RegiaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
    /**
     * Filter, which Regiao to fetch.
     */
    where?: RegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regiaos to fetch.
     */
    orderBy?: RegiaoOrderByWithRelationInput | RegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regiaos.
     */
    cursor?: RegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regiaos.
     */
    distinct?: RegiaoScalarFieldEnum | RegiaoScalarFieldEnum[]
  }

  /**
   * Regiao findFirstOrThrow
   */
  export type RegiaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
    /**
     * Filter, which Regiao to fetch.
     */
    where?: RegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regiaos to fetch.
     */
    orderBy?: RegiaoOrderByWithRelationInput | RegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regiaos.
     */
    cursor?: RegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regiaos.
     */
    distinct?: RegiaoScalarFieldEnum | RegiaoScalarFieldEnum[]
  }

  /**
   * Regiao findMany
   */
  export type RegiaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
    /**
     * Filter, which Regiaos to fetch.
     */
    where?: RegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regiaos to fetch.
     */
    orderBy?: RegiaoOrderByWithRelationInput | RegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regiaos.
     */
    cursor?: RegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regiaos.
     */
    skip?: number
    distinct?: RegiaoScalarFieldEnum | RegiaoScalarFieldEnum[]
  }

  /**
   * Regiao create
   */
  export type RegiaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Regiao.
     */
    data: XOR<RegiaoCreateInput, RegiaoUncheckedCreateInput>
  }

  /**
   * Regiao createMany
   */
  export type RegiaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regiaos.
     */
    data: RegiaoCreateManyInput | RegiaoCreateManyInput[]
  }

  /**
   * Regiao createManyAndReturn
   */
  export type RegiaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Regiaos.
     */
    data: RegiaoCreateManyInput | RegiaoCreateManyInput[]
  }

  /**
   * Regiao update
   */
  export type RegiaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Regiao.
     */
    data: XOR<RegiaoUpdateInput, RegiaoUncheckedUpdateInput>
    /**
     * Choose, which Regiao to update.
     */
    where: RegiaoWhereUniqueInput
  }

  /**
   * Regiao updateMany
   */
  export type RegiaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regiaos.
     */
    data: XOR<RegiaoUpdateManyMutationInput, RegiaoUncheckedUpdateManyInput>
    /**
     * Filter which Regiaos to update
     */
    where?: RegiaoWhereInput
  }

  /**
   * Regiao upsert
   */
  export type RegiaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Regiao to update in case it exists.
     */
    where: RegiaoWhereUniqueInput
    /**
     * In case the Regiao found by the `where` argument doesn't exist, create a new Regiao with this data.
     */
    create: XOR<RegiaoCreateInput, RegiaoUncheckedCreateInput>
    /**
     * In case the Regiao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegiaoUpdateInput, RegiaoUncheckedUpdateInput>
  }

  /**
   * Regiao delete
   */
  export type RegiaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
    /**
     * Filter which Regiao to delete.
     */
    where: RegiaoWhereUniqueInput
  }

  /**
   * Regiao deleteMany
   */
  export type RegiaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regiaos to delete
     */
    where?: RegiaoWhereInput
  }

  /**
   * Regiao.escolas
   */
  export type Regiao$escolasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    where?: EscolaWhereInput
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    cursor?: EscolaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscolaScalarFieldEnum | EscolaScalarFieldEnum[]
  }

  /**
   * Regiao without action
   */
  export type RegiaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regiao
     */
    select?: RegiaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegiaoInclude<ExtArgs> | null
  }


  /**
   * Model Grupo
   */

  export type AggregateGrupo = {
    _count: GrupoCountAggregateOutputType | null
    _avg: GrupoAvgAggregateOutputType | null
    _sum: GrupoSumAggregateOutputType | null
    _min: GrupoMinAggregateOutputType | null
    _max: GrupoMaxAggregateOutputType | null
  }

  export type GrupoAvgAggregateOutputType = {
    id: number | null
  }

  export type GrupoSumAggregateOutputType = {
    id: number | null
  }

  export type GrupoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type GrupoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type GrupoCountAggregateOutputType = {
    id: number
    nome: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type GrupoAvgAggregateInputType = {
    id?: true
  }

  export type GrupoSumAggregateInputType = {
    id?: true
  }

  export type GrupoMinAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type GrupoMaxAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type GrupoCountAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type GrupoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grupo to aggregate.
     */
    where?: GrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grupos to fetch.
     */
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grupos
    **/
    _count?: true | GrupoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GrupoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GrupoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrupoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrupoMaxAggregateInputType
  }

  export type GetGrupoAggregateType<T extends GrupoAggregateArgs> = {
        [P in keyof T & keyof AggregateGrupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrupo[P]>
      : GetScalarType<T[P], AggregateGrupo[P]>
  }




  export type GrupoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GrupoWhereInput
    orderBy?: GrupoOrderByWithAggregationInput | GrupoOrderByWithAggregationInput[]
    by: GrupoScalarFieldEnum[] | GrupoScalarFieldEnum
    having?: GrupoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrupoCountAggregateInputType | true
    _avg?: GrupoAvgAggregateInputType
    _sum?: GrupoSumAggregateInputType
    _min?: GrupoMinAggregateInputType
    _max?: GrupoMaxAggregateInputType
  }

  export type GrupoGroupByOutputType = {
    id: number
    nome: string
    criadoEm: Date
    atualizadoEm: Date
    _count: GrupoCountAggregateOutputType | null
    _avg: GrupoAvgAggregateOutputType | null
    _sum: GrupoSumAggregateOutputType | null
    _min: GrupoMinAggregateOutputType | null
    _max: GrupoMaxAggregateOutputType | null
  }

  type GetGrupoGroupByPayload<T extends GrupoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GrupoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrupoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrupoGroupByOutputType[P]>
            : GetScalarType<T[P], GrupoGroupByOutputType[P]>
        }
      >
    >


  export type GrupoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    escolas?: boolean | Grupo$escolasArgs<ExtArgs>
    _count?: boolean | GrupoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grupo"]>

  export type GrupoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["grupo"]>

  export type GrupoSelectScalar = {
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type GrupoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escolas?: boolean | Grupo$escolasArgs<ExtArgs>
    _count?: boolean | GrupoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GrupoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GrupoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grupo"
    objects: {
      escolas: Prisma.$EscolaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["grupo"]>
    composites: {}
  }

  type GrupoGetPayload<S extends boolean | null | undefined | GrupoDefaultArgs> = $Result.GetResult<Prisma.$GrupoPayload, S>

  type GrupoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GrupoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GrupoCountAggregateInputType | true
    }

  export interface GrupoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grupo'], meta: { name: 'Grupo' } }
    /**
     * Find zero or one Grupo that matches the filter.
     * @param {GrupoFindUniqueArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GrupoFindUniqueArgs>(args: SelectSubset<T, GrupoFindUniqueArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grupo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GrupoFindUniqueOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GrupoFindUniqueOrThrowArgs>(args: SelectSubset<T, GrupoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoFindFirstArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GrupoFindFirstArgs>(args?: SelectSubset<T, GrupoFindFirstArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grupo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoFindFirstOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GrupoFindFirstOrThrowArgs>(args?: SelectSubset<T, GrupoFindFirstOrThrowArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grupos
     * const grupos = await prisma.grupo.findMany()
     * 
     * // Get first 10 Grupos
     * const grupos = await prisma.grupo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grupoWithIdOnly = await prisma.grupo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GrupoFindManyArgs>(args?: SelectSubset<T, GrupoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grupo.
     * @param {GrupoCreateArgs} args - Arguments to create a Grupo.
     * @example
     * // Create one Grupo
     * const Grupo = await prisma.grupo.create({
     *   data: {
     *     // ... data to create a Grupo
     *   }
     * })
     * 
     */
    create<T extends GrupoCreateArgs>(args: SelectSubset<T, GrupoCreateArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grupos.
     * @param {GrupoCreateManyArgs} args - Arguments to create many Grupos.
     * @example
     * // Create many Grupos
     * const grupo = await prisma.grupo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GrupoCreateManyArgs>(args?: SelectSubset<T, GrupoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grupos and returns the data saved in the database.
     * @param {GrupoCreateManyAndReturnArgs} args - Arguments to create many Grupos.
     * @example
     * // Create many Grupos
     * const grupo = await prisma.grupo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grupos and only return the `id`
     * const grupoWithIdOnly = await prisma.grupo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GrupoCreateManyAndReturnArgs>(args?: SelectSubset<T, GrupoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Grupo.
     * @param {GrupoDeleteArgs} args - Arguments to delete one Grupo.
     * @example
     * // Delete one Grupo
     * const Grupo = await prisma.grupo.delete({
     *   where: {
     *     // ... filter to delete one Grupo
     *   }
     * })
     * 
     */
    delete<T extends GrupoDeleteArgs>(args: SelectSubset<T, GrupoDeleteArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grupo.
     * @param {GrupoUpdateArgs} args - Arguments to update one Grupo.
     * @example
     * // Update one Grupo
     * const grupo = await prisma.grupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GrupoUpdateArgs>(args: SelectSubset<T, GrupoUpdateArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grupos.
     * @param {GrupoDeleteManyArgs} args - Arguments to filter Grupos to delete.
     * @example
     * // Delete a few Grupos
     * const { count } = await prisma.grupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GrupoDeleteManyArgs>(args?: SelectSubset<T, GrupoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grupos
     * const grupo = await prisma.grupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GrupoUpdateManyArgs>(args: SelectSubset<T, GrupoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grupo.
     * @param {GrupoUpsertArgs} args - Arguments to update or create a Grupo.
     * @example
     * // Update or create a Grupo
     * const grupo = await prisma.grupo.upsert({
     *   create: {
     *     // ... data to create a Grupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grupo we want to update
     *   }
     * })
     */
    upsert<T extends GrupoUpsertArgs>(args: SelectSubset<T, GrupoUpsertArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoCountArgs} args - Arguments to filter Grupos to count.
     * @example
     * // Count the number of Grupos
     * const count = await prisma.grupo.count({
     *   where: {
     *     // ... the filter for the Grupos we want to count
     *   }
     * })
    **/
    count<T extends GrupoCountArgs>(
      args?: Subset<T, GrupoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrupoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrupoAggregateArgs>(args: Subset<T, GrupoAggregateArgs>): Prisma.PrismaPromise<GetGrupoAggregateType<T>>

    /**
     * Group by Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GrupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GrupoGroupByArgs['orderBy'] }
        : { orderBy?: GrupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GrupoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrupoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grupo model
   */
  readonly fields: GrupoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GrupoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    escolas<T extends Grupo$escolasArgs<ExtArgs> = {}>(args?: Subset<T, Grupo$escolasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grupo model
   */ 
  interface GrupoFieldRefs {
    readonly id: FieldRef<"Grupo", 'Int'>
    readonly nome: FieldRef<"Grupo", 'String'>
    readonly criadoEm: FieldRef<"Grupo", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Grupo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grupo findUnique
   */
  export type GrupoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupo to fetch.
     */
    where: GrupoWhereUniqueInput
  }

  /**
   * Grupo findUniqueOrThrow
   */
  export type GrupoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupo to fetch.
     */
    where: GrupoWhereUniqueInput
  }

  /**
   * Grupo findFirst
   */
  export type GrupoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupo to fetch.
     */
    where?: GrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grupos to fetch.
     */
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grupos.
     */
    cursor?: GrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * Grupo findFirstOrThrow
   */
  export type GrupoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupo to fetch.
     */
    where?: GrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grupos to fetch.
     */
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grupos.
     */
    cursor?: GrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * Grupo findMany
   */
  export type GrupoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter, which Grupos to fetch.
     */
    where?: GrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grupos to fetch.
     */
    orderBy?: GrupoOrderByWithRelationInput | GrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grupos.
     */
    cursor?: GrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grupos.
     */
    skip?: number
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * Grupo create
   */
  export type GrupoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * The data needed to create a Grupo.
     */
    data: XOR<GrupoCreateInput, GrupoUncheckedCreateInput>
  }

  /**
   * Grupo createMany
   */
  export type GrupoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grupos.
     */
    data: GrupoCreateManyInput | GrupoCreateManyInput[]
  }

  /**
   * Grupo createManyAndReturn
   */
  export type GrupoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Grupos.
     */
    data: GrupoCreateManyInput | GrupoCreateManyInput[]
  }

  /**
   * Grupo update
   */
  export type GrupoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * The data needed to update a Grupo.
     */
    data: XOR<GrupoUpdateInput, GrupoUncheckedUpdateInput>
    /**
     * Choose, which Grupo to update.
     */
    where: GrupoWhereUniqueInput
  }

  /**
   * Grupo updateMany
   */
  export type GrupoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grupos.
     */
    data: XOR<GrupoUpdateManyMutationInput, GrupoUncheckedUpdateManyInput>
    /**
     * Filter which Grupos to update
     */
    where?: GrupoWhereInput
  }

  /**
   * Grupo upsert
   */
  export type GrupoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * The filter to search for the Grupo to update in case it exists.
     */
    where: GrupoWhereUniqueInput
    /**
     * In case the Grupo found by the `where` argument doesn't exist, create a new Grupo with this data.
     */
    create: XOR<GrupoCreateInput, GrupoUncheckedCreateInput>
    /**
     * In case the Grupo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GrupoUpdateInput, GrupoUncheckedUpdateInput>
  }

  /**
   * Grupo delete
   */
  export type GrupoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    /**
     * Filter which Grupo to delete.
     */
    where: GrupoWhereUniqueInput
  }

  /**
   * Grupo deleteMany
   */
  export type GrupoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grupos to delete
     */
    where?: GrupoWhereInput
  }

  /**
   * Grupo.escolas
   */
  export type Grupo$escolasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    where?: EscolaWhereInput
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    cursor?: EscolaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscolaScalarFieldEnum | EscolaScalarFieldEnum[]
  }

  /**
   * Grupo without action
   */
  export type GrupoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
  }


  /**
   * Model Escola
   */

  export type AggregateEscola = {
    _count: EscolaCountAggregateOutputType | null
    _avg: EscolaAvgAggregateOutputType | null
    _sum: EscolaSumAggregateOutputType | null
    _min: EscolaMinAggregateOutputType | null
    _max: EscolaMaxAggregateOutputType | null
  }

  export type EscolaAvgAggregateOutputType = {
    id: number | null
    regiaoId: number | null
    grupoId: number | null
  }

  export type EscolaSumAggregateOutputType = {
    id: number | null
    regiaoId: number | null
    grupoId: number | null
  }

  export type EscolaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    regiaoId: number | null
    grupoId: number | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type EscolaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    regiaoId: number | null
    grupoId: number | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type EscolaCountAggregateOutputType = {
    id: number
    nome: number
    regiaoId: number
    grupoId: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type EscolaAvgAggregateInputType = {
    id?: true
    regiaoId?: true
    grupoId?: true
  }

  export type EscolaSumAggregateInputType = {
    id?: true
    regiaoId?: true
    grupoId?: true
  }

  export type EscolaMinAggregateInputType = {
    id?: true
    nome?: true
    regiaoId?: true
    grupoId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type EscolaMaxAggregateInputType = {
    id?: true
    nome?: true
    regiaoId?: true
    grupoId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type EscolaCountAggregateInputType = {
    id?: true
    nome?: true
    regiaoId?: true
    grupoId?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type EscolaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escola to aggregate.
     */
    where?: EscolaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolas to fetch.
     */
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscolaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Escolas
    **/
    _count?: true | EscolaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscolaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscolaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscolaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscolaMaxAggregateInputType
  }

  export type GetEscolaAggregateType<T extends EscolaAggregateArgs> = {
        [P in keyof T & keyof AggregateEscola]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscola[P]>
      : GetScalarType<T[P], AggregateEscola[P]>
  }




  export type EscolaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscolaWhereInput
    orderBy?: EscolaOrderByWithAggregationInput | EscolaOrderByWithAggregationInput[]
    by: EscolaScalarFieldEnum[] | EscolaScalarFieldEnum
    having?: EscolaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscolaCountAggregateInputType | true
    _avg?: EscolaAvgAggregateInputType
    _sum?: EscolaSumAggregateInputType
    _min?: EscolaMinAggregateInputType
    _max?: EscolaMaxAggregateInputType
  }

  export type EscolaGroupByOutputType = {
    id: number
    nome: string
    regiaoId: number
    grupoId: number | null
    criadoEm: Date
    atualizadoEm: Date
    _count: EscolaCountAggregateOutputType | null
    _avg: EscolaAvgAggregateOutputType | null
    _sum: EscolaSumAggregateOutputType | null
    _min: EscolaMinAggregateOutputType | null
    _max: EscolaMaxAggregateOutputType | null
  }

  type GetEscolaGroupByPayload<T extends EscolaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscolaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscolaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscolaGroupByOutputType[P]>
            : GetScalarType<T[P], EscolaGroupByOutputType[P]>
        }
      >
    >


  export type EscolaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    regiaoId?: boolean
    grupoId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    regiao?: boolean | RegiaoDefaultArgs<ExtArgs>
    grupo?: boolean | Escola$grupoArgs<ExtArgs>
    turmas?: boolean | Escola$turmasArgs<ExtArgs>
    usuarios?: boolean | Escola$usuariosArgs<ExtArgs>
    _count?: boolean | EscolaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escola"]>

  export type EscolaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    regiaoId?: boolean
    grupoId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    regiao?: boolean | RegiaoDefaultArgs<ExtArgs>
    grupo?: boolean | Escola$grupoArgs<ExtArgs>
  }, ExtArgs["result"]["escola"]>

  export type EscolaSelectScalar = {
    id?: boolean
    nome?: boolean
    regiaoId?: boolean
    grupoId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type EscolaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regiao?: boolean | RegiaoDefaultArgs<ExtArgs>
    grupo?: boolean | Escola$grupoArgs<ExtArgs>
    turmas?: boolean | Escola$turmasArgs<ExtArgs>
    usuarios?: boolean | Escola$usuariosArgs<ExtArgs>
    _count?: boolean | EscolaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EscolaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regiao?: boolean | RegiaoDefaultArgs<ExtArgs>
    grupo?: boolean | Escola$grupoArgs<ExtArgs>
  }

  export type $EscolaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Escola"
    objects: {
      regiao: Prisma.$RegiaoPayload<ExtArgs>
      grupo: Prisma.$GrupoPayload<ExtArgs> | null
      turmas: Prisma.$TurmaPayload<ExtArgs>[]
      usuarios: Prisma.$EscolaUsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      regiaoId: number
      grupoId: number | null
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["escola"]>
    composites: {}
  }

  type EscolaGetPayload<S extends boolean | null | undefined | EscolaDefaultArgs> = $Result.GetResult<Prisma.$EscolaPayload, S>

  type EscolaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscolaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscolaCountAggregateInputType | true
    }

  export interface EscolaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Escola'], meta: { name: 'Escola' } }
    /**
     * Find zero or one Escola that matches the filter.
     * @param {EscolaFindUniqueArgs} args - Arguments to find a Escola
     * @example
     * // Get one Escola
     * const escola = await prisma.escola.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscolaFindUniqueArgs>(args: SelectSubset<T, EscolaFindUniqueArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Escola that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscolaFindUniqueOrThrowArgs} args - Arguments to find a Escola
     * @example
     * // Get one Escola
     * const escola = await prisma.escola.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscolaFindUniqueOrThrowArgs>(args: SelectSubset<T, EscolaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Escola that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaFindFirstArgs} args - Arguments to find a Escola
     * @example
     * // Get one Escola
     * const escola = await prisma.escola.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscolaFindFirstArgs>(args?: SelectSubset<T, EscolaFindFirstArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Escola that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaFindFirstOrThrowArgs} args - Arguments to find a Escola
     * @example
     * // Get one Escola
     * const escola = await prisma.escola.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscolaFindFirstOrThrowArgs>(args?: SelectSubset<T, EscolaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Escolas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escolas
     * const escolas = await prisma.escola.findMany()
     * 
     * // Get first 10 Escolas
     * const escolas = await prisma.escola.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escolaWithIdOnly = await prisma.escola.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscolaFindManyArgs>(args?: SelectSubset<T, EscolaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Escola.
     * @param {EscolaCreateArgs} args - Arguments to create a Escola.
     * @example
     * // Create one Escola
     * const Escola = await prisma.escola.create({
     *   data: {
     *     // ... data to create a Escola
     *   }
     * })
     * 
     */
    create<T extends EscolaCreateArgs>(args: SelectSubset<T, EscolaCreateArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Escolas.
     * @param {EscolaCreateManyArgs} args - Arguments to create many Escolas.
     * @example
     * // Create many Escolas
     * const escola = await prisma.escola.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscolaCreateManyArgs>(args?: SelectSubset<T, EscolaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Escolas and returns the data saved in the database.
     * @param {EscolaCreateManyAndReturnArgs} args - Arguments to create many Escolas.
     * @example
     * // Create many Escolas
     * const escola = await prisma.escola.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Escolas and only return the `id`
     * const escolaWithIdOnly = await prisma.escola.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscolaCreateManyAndReturnArgs>(args?: SelectSubset<T, EscolaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Escola.
     * @param {EscolaDeleteArgs} args - Arguments to delete one Escola.
     * @example
     * // Delete one Escola
     * const Escola = await prisma.escola.delete({
     *   where: {
     *     // ... filter to delete one Escola
     *   }
     * })
     * 
     */
    delete<T extends EscolaDeleteArgs>(args: SelectSubset<T, EscolaDeleteArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Escola.
     * @param {EscolaUpdateArgs} args - Arguments to update one Escola.
     * @example
     * // Update one Escola
     * const escola = await prisma.escola.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscolaUpdateArgs>(args: SelectSubset<T, EscolaUpdateArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Escolas.
     * @param {EscolaDeleteManyArgs} args - Arguments to filter Escolas to delete.
     * @example
     * // Delete a few Escolas
     * const { count } = await prisma.escola.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscolaDeleteManyArgs>(args?: SelectSubset<T, EscolaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escolas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escolas
     * const escola = await prisma.escola.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscolaUpdateManyArgs>(args: SelectSubset<T, EscolaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Escola.
     * @param {EscolaUpsertArgs} args - Arguments to update or create a Escola.
     * @example
     * // Update or create a Escola
     * const escola = await prisma.escola.upsert({
     *   create: {
     *     // ... data to create a Escola
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escola we want to update
     *   }
     * })
     */
    upsert<T extends EscolaUpsertArgs>(args: SelectSubset<T, EscolaUpsertArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Escolas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaCountArgs} args - Arguments to filter Escolas to count.
     * @example
     * // Count the number of Escolas
     * const count = await prisma.escola.count({
     *   where: {
     *     // ... the filter for the Escolas we want to count
     *   }
     * })
    **/
    count<T extends EscolaCountArgs>(
      args?: Subset<T, EscolaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscolaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escola.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscolaAggregateArgs>(args: Subset<T, EscolaAggregateArgs>): Prisma.PrismaPromise<GetEscolaAggregateType<T>>

    /**
     * Group by Escola.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscolaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscolaGroupByArgs['orderBy'] }
        : { orderBy?: EscolaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscolaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscolaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Escola model
   */
  readonly fields: EscolaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Escola.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscolaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    regiao<T extends RegiaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegiaoDefaultArgs<ExtArgs>>): Prisma__RegiaoClient<$Result.GetResult<Prisma.$RegiaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    grupo<T extends Escola$grupoArgs<ExtArgs> = {}>(args?: Subset<T, Escola$grupoArgs<ExtArgs>>): Prisma__GrupoClient<$Result.GetResult<Prisma.$GrupoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    turmas<T extends Escola$turmasArgs<ExtArgs> = {}>(args?: Subset<T, Escola$turmasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "findMany"> | Null>
    usuarios<T extends Escola$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Escola$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Escola model
   */ 
  interface EscolaFieldRefs {
    readonly id: FieldRef<"Escola", 'Int'>
    readonly nome: FieldRef<"Escola", 'String'>
    readonly regiaoId: FieldRef<"Escola", 'Int'>
    readonly grupoId: FieldRef<"Escola", 'Int'>
    readonly criadoEm: FieldRef<"Escola", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Escola", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Escola findUnique
   */
  export type EscolaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escola to fetch.
     */
    where: EscolaWhereUniqueInput
  }

  /**
   * Escola findUniqueOrThrow
   */
  export type EscolaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escola to fetch.
     */
    where: EscolaWhereUniqueInput
  }

  /**
   * Escola findFirst
   */
  export type EscolaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escola to fetch.
     */
    where?: EscolaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolas to fetch.
     */
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escolas.
     */
    cursor?: EscolaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escolas.
     */
    distinct?: EscolaScalarFieldEnum | EscolaScalarFieldEnum[]
  }

  /**
   * Escola findFirstOrThrow
   */
  export type EscolaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escola to fetch.
     */
    where?: EscolaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolas to fetch.
     */
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escolas.
     */
    cursor?: EscolaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escolas.
     */
    distinct?: EscolaScalarFieldEnum | EscolaScalarFieldEnum[]
  }

  /**
   * Escola findMany
   */
  export type EscolaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escolas to fetch.
     */
    where?: EscolaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolas to fetch.
     */
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Escolas.
     */
    cursor?: EscolaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolas.
     */
    skip?: number
    distinct?: EscolaScalarFieldEnum | EscolaScalarFieldEnum[]
  }

  /**
   * Escola create
   */
  export type EscolaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * The data needed to create a Escola.
     */
    data: XOR<EscolaCreateInput, EscolaUncheckedCreateInput>
  }

  /**
   * Escola createMany
   */
  export type EscolaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Escolas.
     */
    data: EscolaCreateManyInput | EscolaCreateManyInput[]
  }

  /**
   * Escola createManyAndReturn
   */
  export type EscolaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Escolas.
     */
    data: EscolaCreateManyInput | EscolaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Escola update
   */
  export type EscolaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * The data needed to update a Escola.
     */
    data: XOR<EscolaUpdateInput, EscolaUncheckedUpdateInput>
    /**
     * Choose, which Escola to update.
     */
    where: EscolaWhereUniqueInput
  }

  /**
   * Escola updateMany
   */
  export type EscolaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Escolas.
     */
    data: XOR<EscolaUpdateManyMutationInput, EscolaUncheckedUpdateManyInput>
    /**
     * Filter which Escolas to update
     */
    where?: EscolaWhereInput
  }

  /**
   * Escola upsert
   */
  export type EscolaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * The filter to search for the Escola to update in case it exists.
     */
    where: EscolaWhereUniqueInput
    /**
     * In case the Escola found by the `where` argument doesn't exist, create a new Escola with this data.
     */
    create: XOR<EscolaCreateInput, EscolaUncheckedCreateInput>
    /**
     * In case the Escola was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscolaUpdateInput, EscolaUncheckedUpdateInput>
  }

  /**
   * Escola delete
   */
  export type EscolaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter which Escola to delete.
     */
    where: EscolaWhereUniqueInput
  }

  /**
   * Escola deleteMany
   */
  export type EscolaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escolas to delete
     */
    where?: EscolaWhereInput
  }

  /**
   * Escola.grupo
   */
  export type Escola$grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grupo
     */
    select?: GrupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrupoInclude<ExtArgs> | null
    where?: GrupoWhereInput
  }

  /**
   * Escola.turmas
   */
  export type Escola$turmasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    where?: TurmaWhereInput
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    cursor?: TurmaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }

  /**
   * Escola.usuarios
   */
  export type Escola$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    where?: EscolaUsuarioWhereInput
    orderBy?: EscolaUsuarioOrderByWithRelationInput | EscolaUsuarioOrderByWithRelationInput[]
    cursor?: EscolaUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscolaUsuarioScalarFieldEnum | EscolaUsuarioScalarFieldEnum[]
  }

  /**
   * Escola without action
   */
  export type EscolaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaInclude<ExtArgs> | null
  }


  /**
   * Model EscolaUsuario
   */

  export type AggregateEscolaUsuario = {
    _count: EscolaUsuarioCountAggregateOutputType | null
    _avg: EscolaUsuarioAvgAggregateOutputType | null
    _sum: EscolaUsuarioSumAggregateOutputType | null
    _min: EscolaUsuarioMinAggregateOutputType | null
    _max: EscolaUsuarioMaxAggregateOutputType | null
  }

  export type EscolaUsuarioAvgAggregateOutputType = {
    id: number | null
    escolaId: number | null
    usuarioId: number | null
  }

  export type EscolaUsuarioSumAggregateOutputType = {
    id: number | null
    escolaId: number | null
    usuarioId: number | null
  }

  export type EscolaUsuarioMinAggregateOutputType = {
    id: number | null
    escolaId: number | null
    usuarioId: number | null
    criadoEm: Date | null
  }

  export type EscolaUsuarioMaxAggregateOutputType = {
    id: number | null
    escolaId: number | null
    usuarioId: number | null
    criadoEm: Date | null
  }

  export type EscolaUsuarioCountAggregateOutputType = {
    id: number
    escolaId: number
    usuarioId: number
    criadoEm: number
    _all: number
  }


  export type EscolaUsuarioAvgAggregateInputType = {
    id?: true
    escolaId?: true
    usuarioId?: true
  }

  export type EscolaUsuarioSumAggregateInputType = {
    id?: true
    escolaId?: true
    usuarioId?: true
  }

  export type EscolaUsuarioMinAggregateInputType = {
    id?: true
    escolaId?: true
    usuarioId?: true
    criadoEm?: true
  }

  export type EscolaUsuarioMaxAggregateInputType = {
    id?: true
    escolaId?: true
    usuarioId?: true
    criadoEm?: true
  }

  export type EscolaUsuarioCountAggregateInputType = {
    id?: true
    escolaId?: true
    usuarioId?: true
    criadoEm?: true
    _all?: true
  }

  export type EscolaUsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscolaUsuario to aggregate.
     */
    where?: EscolaUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscolaUsuarios to fetch.
     */
    orderBy?: EscolaUsuarioOrderByWithRelationInput | EscolaUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscolaUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscolaUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscolaUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscolaUsuarios
    **/
    _count?: true | EscolaUsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscolaUsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscolaUsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscolaUsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscolaUsuarioMaxAggregateInputType
  }

  export type GetEscolaUsuarioAggregateType<T extends EscolaUsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateEscolaUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscolaUsuario[P]>
      : GetScalarType<T[P], AggregateEscolaUsuario[P]>
  }




  export type EscolaUsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscolaUsuarioWhereInput
    orderBy?: EscolaUsuarioOrderByWithAggregationInput | EscolaUsuarioOrderByWithAggregationInput[]
    by: EscolaUsuarioScalarFieldEnum[] | EscolaUsuarioScalarFieldEnum
    having?: EscolaUsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscolaUsuarioCountAggregateInputType | true
    _avg?: EscolaUsuarioAvgAggregateInputType
    _sum?: EscolaUsuarioSumAggregateInputType
    _min?: EscolaUsuarioMinAggregateInputType
    _max?: EscolaUsuarioMaxAggregateInputType
  }

  export type EscolaUsuarioGroupByOutputType = {
    id: number
    escolaId: number
    usuarioId: number
    criadoEm: Date
    _count: EscolaUsuarioCountAggregateOutputType | null
    _avg: EscolaUsuarioAvgAggregateOutputType | null
    _sum: EscolaUsuarioSumAggregateOutputType | null
    _min: EscolaUsuarioMinAggregateOutputType | null
    _max: EscolaUsuarioMaxAggregateOutputType | null
  }

  type GetEscolaUsuarioGroupByPayload<T extends EscolaUsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscolaUsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscolaUsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscolaUsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], EscolaUsuarioGroupByOutputType[P]>
        }
      >
    >


  export type EscolaUsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escolaId?: boolean
    usuarioId?: boolean
    criadoEm?: boolean
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escolaUsuario"]>

  export type EscolaUsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escolaId?: boolean
    usuarioId?: boolean
    criadoEm?: boolean
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escolaUsuario"]>

  export type EscolaUsuarioSelectScalar = {
    id?: boolean
    escolaId?: boolean
    usuarioId?: boolean
    criadoEm?: boolean
  }

  export type EscolaUsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type EscolaUsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $EscolaUsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscolaUsuario"
    objects: {
      escola: Prisma.$EscolaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      escolaId: number
      usuarioId: number
      criadoEm: Date
    }, ExtArgs["result"]["escolaUsuario"]>
    composites: {}
  }

  type EscolaUsuarioGetPayload<S extends boolean | null | undefined | EscolaUsuarioDefaultArgs> = $Result.GetResult<Prisma.$EscolaUsuarioPayload, S>

  type EscolaUsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EscolaUsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EscolaUsuarioCountAggregateInputType | true
    }

  export interface EscolaUsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscolaUsuario'], meta: { name: 'EscolaUsuario' } }
    /**
     * Find zero or one EscolaUsuario that matches the filter.
     * @param {EscolaUsuarioFindUniqueArgs} args - Arguments to find a EscolaUsuario
     * @example
     * // Get one EscolaUsuario
     * const escolaUsuario = await prisma.escolaUsuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscolaUsuarioFindUniqueArgs>(args: SelectSubset<T, EscolaUsuarioFindUniqueArgs<ExtArgs>>): Prisma__EscolaUsuarioClient<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EscolaUsuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EscolaUsuarioFindUniqueOrThrowArgs} args - Arguments to find a EscolaUsuario
     * @example
     * // Get one EscolaUsuario
     * const escolaUsuario = await prisma.escolaUsuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscolaUsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, EscolaUsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscolaUsuarioClient<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EscolaUsuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaUsuarioFindFirstArgs} args - Arguments to find a EscolaUsuario
     * @example
     * // Get one EscolaUsuario
     * const escolaUsuario = await prisma.escolaUsuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscolaUsuarioFindFirstArgs>(args?: SelectSubset<T, EscolaUsuarioFindFirstArgs<ExtArgs>>): Prisma__EscolaUsuarioClient<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EscolaUsuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaUsuarioFindFirstOrThrowArgs} args - Arguments to find a EscolaUsuario
     * @example
     * // Get one EscolaUsuario
     * const escolaUsuario = await prisma.escolaUsuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscolaUsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, EscolaUsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscolaUsuarioClient<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EscolaUsuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaUsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscolaUsuarios
     * const escolaUsuarios = await prisma.escolaUsuario.findMany()
     * 
     * // Get first 10 EscolaUsuarios
     * const escolaUsuarios = await prisma.escolaUsuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escolaUsuarioWithIdOnly = await prisma.escolaUsuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscolaUsuarioFindManyArgs>(args?: SelectSubset<T, EscolaUsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EscolaUsuario.
     * @param {EscolaUsuarioCreateArgs} args - Arguments to create a EscolaUsuario.
     * @example
     * // Create one EscolaUsuario
     * const EscolaUsuario = await prisma.escolaUsuario.create({
     *   data: {
     *     // ... data to create a EscolaUsuario
     *   }
     * })
     * 
     */
    create<T extends EscolaUsuarioCreateArgs>(args: SelectSubset<T, EscolaUsuarioCreateArgs<ExtArgs>>): Prisma__EscolaUsuarioClient<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EscolaUsuarios.
     * @param {EscolaUsuarioCreateManyArgs} args - Arguments to create many EscolaUsuarios.
     * @example
     * // Create many EscolaUsuarios
     * const escolaUsuario = await prisma.escolaUsuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscolaUsuarioCreateManyArgs>(args?: SelectSubset<T, EscolaUsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscolaUsuarios and returns the data saved in the database.
     * @param {EscolaUsuarioCreateManyAndReturnArgs} args - Arguments to create many EscolaUsuarios.
     * @example
     * // Create many EscolaUsuarios
     * const escolaUsuario = await prisma.escolaUsuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscolaUsuarios and only return the `id`
     * const escolaUsuarioWithIdOnly = await prisma.escolaUsuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscolaUsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, EscolaUsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EscolaUsuario.
     * @param {EscolaUsuarioDeleteArgs} args - Arguments to delete one EscolaUsuario.
     * @example
     * // Delete one EscolaUsuario
     * const EscolaUsuario = await prisma.escolaUsuario.delete({
     *   where: {
     *     // ... filter to delete one EscolaUsuario
     *   }
     * })
     * 
     */
    delete<T extends EscolaUsuarioDeleteArgs>(args: SelectSubset<T, EscolaUsuarioDeleteArgs<ExtArgs>>): Prisma__EscolaUsuarioClient<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EscolaUsuario.
     * @param {EscolaUsuarioUpdateArgs} args - Arguments to update one EscolaUsuario.
     * @example
     * // Update one EscolaUsuario
     * const escolaUsuario = await prisma.escolaUsuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscolaUsuarioUpdateArgs>(args: SelectSubset<T, EscolaUsuarioUpdateArgs<ExtArgs>>): Prisma__EscolaUsuarioClient<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EscolaUsuarios.
     * @param {EscolaUsuarioDeleteManyArgs} args - Arguments to filter EscolaUsuarios to delete.
     * @example
     * // Delete a few EscolaUsuarios
     * const { count } = await prisma.escolaUsuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscolaUsuarioDeleteManyArgs>(args?: SelectSubset<T, EscolaUsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscolaUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaUsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscolaUsuarios
     * const escolaUsuario = await prisma.escolaUsuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscolaUsuarioUpdateManyArgs>(args: SelectSubset<T, EscolaUsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EscolaUsuario.
     * @param {EscolaUsuarioUpsertArgs} args - Arguments to update or create a EscolaUsuario.
     * @example
     * // Update or create a EscolaUsuario
     * const escolaUsuario = await prisma.escolaUsuario.upsert({
     *   create: {
     *     // ... data to create a EscolaUsuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscolaUsuario we want to update
     *   }
     * })
     */
    upsert<T extends EscolaUsuarioUpsertArgs>(args: SelectSubset<T, EscolaUsuarioUpsertArgs<ExtArgs>>): Prisma__EscolaUsuarioClient<$Result.GetResult<Prisma.$EscolaUsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EscolaUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaUsuarioCountArgs} args - Arguments to filter EscolaUsuarios to count.
     * @example
     * // Count the number of EscolaUsuarios
     * const count = await prisma.escolaUsuario.count({
     *   where: {
     *     // ... the filter for the EscolaUsuarios we want to count
     *   }
     * })
    **/
    count<T extends EscolaUsuarioCountArgs>(
      args?: Subset<T, EscolaUsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscolaUsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscolaUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaUsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscolaUsuarioAggregateArgs>(args: Subset<T, EscolaUsuarioAggregateArgs>): Prisma.PrismaPromise<GetEscolaUsuarioAggregateType<T>>

    /**
     * Group by EscolaUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaUsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscolaUsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscolaUsuarioGroupByArgs['orderBy'] }
        : { orderBy?: EscolaUsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscolaUsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscolaUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscolaUsuario model
   */
  readonly fields: EscolaUsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscolaUsuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscolaUsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    escola<T extends EscolaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscolaDefaultArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscolaUsuario model
   */ 
  interface EscolaUsuarioFieldRefs {
    readonly id: FieldRef<"EscolaUsuario", 'Int'>
    readonly escolaId: FieldRef<"EscolaUsuario", 'Int'>
    readonly usuarioId: FieldRef<"EscolaUsuario", 'Int'>
    readonly criadoEm: FieldRef<"EscolaUsuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EscolaUsuario findUnique
   */
  export type EscolaUsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which EscolaUsuario to fetch.
     */
    where: EscolaUsuarioWhereUniqueInput
  }

  /**
   * EscolaUsuario findUniqueOrThrow
   */
  export type EscolaUsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which EscolaUsuario to fetch.
     */
    where: EscolaUsuarioWhereUniqueInput
  }

  /**
   * EscolaUsuario findFirst
   */
  export type EscolaUsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which EscolaUsuario to fetch.
     */
    where?: EscolaUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscolaUsuarios to fetch.
     */
    orderBy?: EscolaUsuarioOrderByWithRelationInput | EscolaUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscolaUsuarios.
     */
    cursor?: EscolaUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscolaUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscolaUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscolaUsuarios.
     */
    distinct?: EscolaUsuarioScalarFieldEnum | EscolaUsuarioScalarFieldEnum[]
  }

  /**
   * EscolaUsuario findFirstOrThrow
   */
  export type EscolaUsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which EscolaUsuario to fetch.
     */
    where?: EscolaUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscolaUsuarios to fetch.
     */
    orderBy?: EscolaUsuarioOrderByWithRelationInput | EscolaUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscolaUsuarios.
     */
    cursor?: EscolaUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscolaUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscolaUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscolaUsuarios.
     */
    distinct?: EscolaUsuarioScalarFieldEnum | EscolaUsuarioScalarFieldEnum[]
  }

  /**
   * EscolaUsuario findMany
   */
  export type EscolaUsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which EscolaUsuarios to fetch.
     */
    where?: EscolaUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscolaUsuarios to fetch.
     */
    orderBy?: EscolaUsuarioOrderByWithRelationInput | EscolaUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscolaUsuarios.
     */
    cursor?: EscolaUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscolaUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscolaUsuarios.
     */
    skip?: number
    distinct?: EscolaUsuarioScalarFieldEnum | EscolaUsuarioScalarFieldEnum[]
  }

  /**
   * EscolaUsuario create
   */
  export type EscolaUsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a EscolaUsuario.
     */
    data: XOR<EscolaUsuarioCreateInput, EscolaUsuarioUncheckedCreateInput>
  }

  /**
   * EscolaUsuario createMany
   */
  export type EscolaUsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscolaUsuarios.
     */
    data: EscolaUsuarioCreateManyInput | EscolaUsuarioCreateManyInput[]
  }

  /**
   * EscolaUsuario createManyAndReturn
   */
  export type EscolaUsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EscolaUsuarios.
     */
    data: EscolaUsuarioCreateManyInput | EscolaUsuarioCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EscolaUsuario update
   */
  export type EscolaUsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a EscolaUsuario.
     */
    data: XOR<EscolaUsuarioUpdateInput, EscolaUsuarioUncheckedUpdateInput>
    /**
     * Choose, which EscolaUsuario to update.
     */
    where: EscolaUsuarioWhereUniqueInput
  }

  /**
   * EscolaUsuario updateMany
   */
  export type EscolaUsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscolaUsuarios.
     */
    data: XOR<EscolaUsuarioUpdateManyMutationInput, EscolaUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which EscolaUsuarios to update
     */
    where?: EscolaUsuarioWhereInput
  }

  /**
   * EscolaUsuario upsert
   */
  export type EscolaUsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the EscolaUsuario to update in case it exists.
     */
    where: EscolaUsuarioWhereUniqueInput
    /**
     * In case the EscolaUsuario found by the `where` argument doesn't exist, create a new EscolaUsuario with this data.
     */
    create: XOR<EscolaUsuarioCreateInput, EscolaUsuarioUncheckedCreateInput>
    /**
     * In case the EscolaUsuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscolaUsuarioUpdateInput, EscolaUsuarioUncheckedUpdateInput>
  }

  /**
   * EscolaUsuario delete
   */
  export type EscolaUsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
    /**
     * Filter which EscolaUsuario to delete.
     */
    where: EscolaUsuarioWhereUniqueInput
  }

  /**
   * EscolaUsuario deleteMany
   */
  export type EscolaUsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscolaUsuarios to delete
     */
    where?: EscolaUsuarioWhereInput
  }

  /**
   * EscolaUsuario without action
   */
  export type EscolaUsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaUsuario
     */
    select?: EscolaUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaUsuarioInclude<ExtArgs> | null
  }


  /**
   * Model AnoEscolar
   */

  export type AggregateAnoEscolar = {
    _count: AnoEscolarCountAggregateOutputType | null
    _avg: AnoEscolarAvgAggregateOutputType | null
    _sum: AnoEscolarSumAggregateOutputType | null
    _min: AnoEscolarMinAggregateOutputType | null
    _max: AnoEscolarMaxAggregateOutputType | null
  }

  export type AnoEscolarAvgAggregateOutputType = {
    id: number | null
  }

  export type AnoEscolarSumAggregateOutputType = {
    id: number | null
  }

  export type AnoEscolarMinAggregateOutputType = {
    id: number | null
    nome: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AnoEscolarMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AnoEscolarCountAggregateOutputType = {
    id: number
    nome: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type AnoEscolarAvgAggregateInputType = {
    id?: true
  }

  export type AnoEscolarSumAggregateInputType = {
    id?: true
  }

  export type AnoEscolarMinAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AnoEscolarMaxAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AnoEscolarCountAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type AnoEscolarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnoEscolar to aggregate.
     */
    where?: AnoEscolarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnoEscolars to fetch.
     */
    orderBy?: AnoEscolarOrderByWithRelationInput | AnoEscolarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnoEscolarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnoEscolars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnoEscolars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnoEscolars
    **/
    _count?: true | AnoEscolarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnoEscolarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnoEscolarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnoEscolarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnoEscolarMaxAggregateInputType
  }

  export type GetAnoEscolarAggregateType<T extends AnoEscolarAggregateArgs> = {
        [P in keyof T & keyof AggregateAnoEscolar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnoEscolar[P]>
      : GetScalarType<T[P], AggregateAnoEscolar[P]>
  }




  export type AnoEscolarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnoEscolarWhereInput
    orderBy?: AnoEscolarOrderByWithAggregationInput | AnoEscolarOrderByWithAggregationInput[]
    by: AnoEscolarScalarFieldEnum[] | AnoEscolarScalarFieldEnum
    having?: AnoEscolarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnoEscolarCountAggregateInputType | true
    _avg?: AnoEscolarAvgAggregateInputType
    _sum?: AnoEscolarSumAggregateInputType
    _min?: AnoEscolarMinAggregateInputType
    _max?: AnoEscolarMaxAggregateInputType
  }

  export type AnoEscolarGroupByOutputType = {
    id: number
    nome: string
    criadoEm: Date
    atualizadoEm: Date
    _count: AnoEscolarCountAggregateOutputType | null
    _avg: AnoEscolarAvgAggregateOutputType | null
    _sum: AnoEscolarSumAggregateOutputType | null
    _min: AnoEscolarMinAggregateOutputType | null
    _max: AnoEscolarMaxAggregateOutputType | null
  }

  type GetAnoEscolarGroupByPayload<T extends AnoEscolarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnoEscolarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnoEscolarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnoEscolarGroupByOutputType[P]>
            : GetScalarType<T[P], AnoEscolarGroupByOutputType[P]>
        }
      >
    >


  export type AnoEscolarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    turmas?: boolean | AnoEscolar$turmasArgs<ExtArgs>
    _count?: boolean | AnoEscolarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anoEscolar"]>

  export type AnoEscolarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["anoEscolar"]>

  export type AnoEscolarSelectScalar = {
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type AnoEscolarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    turmas?: boolean | AnoEscolar$turmasArgs<ExtArgs>
    _count?: boolean | AnoEscolarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnoEscolarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AnoEscolarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnoEscolar"
    objects: {
      turmas: Prisma.$TurmaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["anoEscolar"]>
    composites: {}
  }

  type AnoEscolarGetPayload<S extends boolean | null | undefined | AnoEscolarDefaultArgs> = $Result.GetResult<Prisma.$AnoEscolarPayload, S>

  type AnoEscolarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnoEscolarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnoEscolarCountAggregateInputType | true
    }

  export interface AnoEscolarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnoEscolar'], meta: { name: 'AnoEscolar' } }
    /**
     * Find zero or one AnoEscolar that matches the filter.
     * @param {AnoEscolarFindUniqueArgs} args - Arguments to find a AnoEscolar
     * @example
     * // Get one AnoEscolar
     * const anoEscolar = await prisma.anoEscolar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnoEscolarFindUniqueArgs>(args: SelectSubset<T, AnoEscolarFindUniqueArgs<ExtArgs>>): Prisma__AnoEscolarClient<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnoEscolar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnoEscolarFindUniqueOrThrowArgs} args - Arguments to find a AnoEscolar
     * @example
     * // Get one AnoEscolar
     * const anoEscolar = await prisma.anoEscolar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnoEscolarFindUniqueOrThrowArgs>(args: SelectSubset<T, AnoEscolarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnoEscolarClient<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnoEscolar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnoEscolarFindFirstArgs} args - Arguments to find a AnoEscolar
     * @example
     * // Get one AnoEscolar
     * const anoEscolar = await prisma.anoEscolar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnoEscolarFindFirstArgs>(args?: SelectSubset<T, AnoEscolarFindFirstArgs<ExtArgs>>): Prisma__AnoEscolarClient<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnoEscolar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnoEscolarFindFirstOrThrowArgs} args - Arguments to find a AnoEscolar
     * @example
     * // Get one AnoEscolar
     * const anoEscolar = await prisma.anoEscolar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnoEscolarFindFirstOrThrowArgs>(args?: SelectSubset<T, AnoEscolarFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnoEscolarClient<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnoEscolars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnoEscolarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnoEscolars
     * const anoEscolars = await prisma.anoEscolar.findMany()
     * 
     * // Get first 10 AnoEscolars
     * const anoEscolars = await prisma.anoEscolar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anoEscolarWithIdOnly = await prisma.anoEscolar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnoEscolarFindManyArgs>(args?: SelectSubset<T, AnoEscolarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnoEscolar.
     * @param {AnoEscolarCreateArgs} args - Arguments to create a AnoEscolar.
     * @example
     * // Create one AnoEscolar
     * const AnoEscolar = await prisma.anoEscolar.create({
     *   data: {
     *     // ... data to create a AnoEscolar
     *   }
     * })
     * 
     */
    create<T extends AnoEscolarCreateArgs>(args: SelectSubset<T, AnoEscolarCreateArgs<ExtArgs>>): Prisma__AnoEscolarClient<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnoEscolars.
     * @param {AnoEscolarCreateManyArgs} args - Arguments to create many AnoEscolars.
     * @example
     * // Create many AnoEscolars
     * const anoEscolar = await prisma.anoEscolar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnoEscolarCreateManyArgs>(args?: SelectSubset<T, AnoEscolarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnoEscolars and returns the data saved in the database.
     * @param {AnoEscolarCreateManyAndReturnArgs} args - Arguments to create many AnoEscolars.
     * @example
     * // Create many AnoEscolars
     * const anoEscolar = await prisma.anoEscolar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnoEscolars and only return the `id`
     * const anoEscolarWithIdOnly = await prisma.anoEscolar.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnoEscolarCreateManyAndReturnArgs>(args?: SelectSubset<T, AnoEscolarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnoEscolar.
     * @param {AnoEscolarDeleteArgs} args - Arguments to delete one AnoEscolar.
     * @example
     * // Delete one AnoEscolar
     * const AnoEscolar = await prisma.anoEscolar.delete({
     *   where: {
     *     // ... filter to delete one AnoEscolar
     *   }
     * })
     * 
     */
    delete<T extends AnoEscolarDeleteArgs>(args: SelectSubset<T, AnoEscolarDeleteArgs<ExtArgs>>): Prisma__AnoEscolarClient<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnoEscolar.
     * @param {AnoEscolarUpdateArgs} args - Arguments to update one AnoEscolar.
     * @example
     * // Update one AnoEscolar
     * const anoEscolar = await prisma.anoEscolar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnoEscolarUpdateArgs>(args: SelectSubset<T, AnoEscolarUpdateArgs<ExtArgs>>): Prisma__AnoEscolarClient<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnoEscolars.
     * @param {AnoEscolarDeleteManyArgs} args - Arguments to filter AnoEscolars to delete.
     * @example
     * // Delete a few AnoEscolars
     * const { count } = await prisma.anoEscolar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnoEscolarDeleteManyArgs>(args?: SelectSubset<T, AnoEscolarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnoEscolars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnoEscolarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnoEscolars
     * const anoEscolar = await prisma.anoEscolar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnoEscolarUpdateManyArgs>(args: SelectSubset<T, AnoEscolarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnoEscolar.
     * @param {AnoEscolarUpsertArgs} args - Arguments to update or create a AnoEscolar.
     * @example
     * // Update or create a AnoEscolar
     * const anoEscolar = await prisma.anoEscolar.upsert({
     *   create: {
     *     // ... data to create a AnoEscolar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnoEscolar we want to update
     *   }
     * })
     */
    upsert<T extends AnoEscolarUpsertArgs>(args: SelectSubset<T, AnoEscolarUpsertArgs<ExtArgs>>): Prisma__AnoEscolarClient<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnoEscolars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnoEscolarCountArgs} args - Arguments to filter AnoEscolars to count.
     * @example
     * // Count the number of AnoEscolars
     * const count = await prisma.anoEscolar.count({
     *   where: {
     *     // ... the filter for the AnoEscolars we want to count
     *   }
     * })
    **/
    count<T extends AnoEscolarCountArgs>(
      args?: Subset<T, AnoEscolarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnoEscolarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnoEscolar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnoEscolarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnoEscolarAggregateArgs>(args: Subset<T, AnoEscolarAggregateArgs>): Prisma.PrismaPromise<GetAnoEscolarAggregateType<T>>

    /**
     * Group by AnoEscolar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnoEscolarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnoEscolarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnoEscolarGroupByArgs['orderBy'] }
        : { orderBy?: AnoEscolarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnoEscolarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnoEscolarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnoEscolar model
   */
  readonly fields: AnoEscolarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnoEscolar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnoEscolarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    turmas<T extends AnoEscolar$turmasArgs<ExtArgs> = {}>(args?: Subset<T, AnoEscolar$turmasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnoEscolar model
   */ 
  interface AnoEscolarFieldRefs {
    readonly id: FieldRef<"AnoEscolar", 'Int'>
    readonly nome: FieldRef<"AnoEscolar", 'String'>
    readonly criadoEm: FieldRef<"AnoEscolar", 'DateTime'>
    readonly atualizadoEm: FieldRef<"AnoEscolar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnoEscolar findUnique
   */
  export type AnoEscolarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
    /**
     * Filter, which AnoEscolar to fetch.
     */
    where: AnoEscolarWhereUniqueInput
  }

  /**
   * AnoEscolar findUniqueOrThrow
   */
  export type AnoEscolarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
    /**
     * Filter, which AnoEscolar to fetch.
     */
    where: AnoEscolarWhereUniqueInput
  }

  /**
   * AnoEscolar findFirst
   */
  export type AnoEscolarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
    /**
     * Filter, which AnoEscolar to fetch.
     */
    where?: AnoEscolarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnoEscolars to fetch.
     */
    orderBy?: AnoEscolarOrderByWithRelationInput | AnoEscolarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnoEscolars.
     */
    cursor?: AnoEscolarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnoEscolars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnoEscolars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnoEscolars.
     */
    distinct?: AnoEscolarScalarFieldEnum | AnoEscolarScalarFieldEnum[]
  }

  /**
   * AnoEscolar findFirstOrThrow
   */
  export type AnoEscolarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
    /**
     * Filter, which AnoEscolar to fetch.
     */
    where?: AnoEscolarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnoEscolars to fetch.
     */
    orderBy?: AnoEscolarOrderByWithRelationInput | AnoEscolarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnoEscolars.
     */
    cursor?: AnoEscolarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnoEscolars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnoEscolars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnoEscolars.
     */
    distinct?: AnoEscolarScalarFieldEnum | AnoEscolarScalarFieldEnum[]
  }

  /**
   * AnoEscolar findMany
   */
  export type AnoEscolarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
    /**
     * Filter, which AnoEscolars to fetch.
     */
    where?: AnoEscolarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnoEscolars to fetch.
     */
    orderBy?: AnoEscolarOrderByWithRelationInput | AnoEscolarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnoEscolars.
     */
    cursor?: AnoEscolarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnoEscolars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnoEscolars.
     */
    skip?: number
    distinct?: AnoEscolarScalarFieldEnum | AnoEscolarScalarFieldEnum[]
  }

  /**
   * AnoEscolar create
   */
  export type AnoEscolarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
    /**
     * The data needed to create a AnoEscolar.
     */
    data: XOR<AnoEscolarCreateInput, AnoEscolarUncheckedCreateInput>
  }

  /**
   * AnoEscolar createMany
   */
  export type AnoEscolarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnoEscolars.
     */
    data: AnoEscolarCreateManyInput | AnoEscolarCreateManyInput[]
  }

  /**
   * AnoEscolar createManyAndReturn
   */
  export type AnoEscolarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnoEscolars.
     */
    data: AnoEscolarCreateManyInput | AnoEscolarCreateManyInput[]
  }

  /**
   * AnoEscolar update
   */
  export type AnoEscolarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
    /**
     * The data needed to update a AnoEscolar.
     */
    data: XOR<AnoEscolarUpdateInput, AnoEscolarUncheckedUpdateInput>
    /**
     * Choose, which AnoEscolar to update.
     */
    where: AnoEscolarWhereUniqueInput
  }

  /**
   * AnoEscolar updateMany
   */
  export type AnoEscolarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnoEscolars.
     */
    data: XOR<AnoEscolarUpdateManyMutationInput, AnoEscolarUncheckedUpdateManyInput>
    /**
     * Filter which AnoEscolars to update
     */
    where?: AnoEscolarWhereInput
  }

  /**
   * AnoEscolar upsert
   */
  export type AnoEscolarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
    /**
     * The filter to search for the AnoEscolar to update in case it exists.
     */
    where: AnoEscolarWhereUniqueInput
    /**
     * In case the AnoEscolar found by the `where` argument doesn't exist, create a new AnoEscolar with this data.
     */
    create: XOR<AnoEscolarCreateInput, AnoEscolarUncheckedCreateInput>
    /**
     * In case the AnoEscolar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnoEscolarUpdateInput, AnoEscolarUncheckedUpdateInput>
  }

  /**
   * AnoEscolar delete
   */
  export type AnoEscolarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
    /**
     * Filter which AnoEscolar to delete.
     */
    where: AnoEscolarWhereUniqueInput
  }

  /**
   * AnoEscolar deleteMany
   */
  export type AnoEscolarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnoEscolars to delete
     */
    where?: AnoEscolarWhereInput
  }

  /**
   * AnoEscolar.turmas
   */
  export type AnoEscolar$turmasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    where?: TurmaWhereInput
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    cursor?: TurmaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }

  /**
   * AnoEscolar without action
   */
  export type AnoEscolarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnoEscolar
     */
    select?: AnoEscolarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnoEscolarInclude<ExtArgs> | null
  }


  /**
   * Model Turma
   */

  export type AggregateTurma = {
    _count: TurmaCountAggregateOutputType | null
    _avg: TurmaAvgAggregateOutputType | null
    _sum: TurmaSumAggregateOutputType | null
    _min: TurmaMinAggregateOutputType | null
    _max: TurmaMaxAggregateOutputType | null
  }

  export type TurmaAvgAggregateOutputType = {
    id: number | null
    escolaId: number | null
    anoEscolarId: number | null
  }

  export type TurmaSumAggregateOutputType = {
    id: number | null
    escolaId: number | null
    anoEscolarId: number | null
  }

  export type TurmaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    escolaId: number | null
    anoEscolarId: number | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TurmaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    escolaId: number | null
    anoEscolarId: number | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TurmaCountAggregateOutputType = {
    id: number
    nome: number
    escolaId: number
    anoEscolarId: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type TurmaAvgAggregateInputType = {
    id?: true
    escolaId?: true
    anoEscolarId?: true
  }

  export type TurmaSumAggregateInputType = {
    id?: true
    escolaId?: true
    anoEscolarId?: true
  }

  export type TurmaMinAggregateInputType = {
    id?: true
    nome?: true
    escolaId?: true
    anoEscolarId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TurmaMaxAggregateInputType = {
    id?: true
    nome?: true
    escolaId?: true
    anoEscolarId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TurmaCountAggregateInputType = {
    id?: true
    nome?: true
    escolaId?: true
    anoEscolarId?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type TurmaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Turma to aggregate.
     */
    where?: TurmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turmas to fetch.
     */
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TurmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Turmas
    **/
    _count?: true | TurmaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TurmaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TurmaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TurmaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TurmaMaxAggregateInputType
  }

  export type GetTurmaAggregateType<T extends TurmaAggregateArgs> = {
        [P in keyof T & keyof AggregateTurma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTurma[P]>
      : GetScalarType<T[P], AggregateTurma[P]>
  }




  export type TurmaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TurmaWhereInput
    orderBy?: TurmaOrderByWithAggregationInput | TurmaOrderByWithAggregationInput[]
    by: TurmaScalarFieldEnum[] | TurmaScalarFieldEnum
    having?: TurmaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TurmaCountAggregateInputType | true
    _avg?: TurmaAvgAggregateInputType
    _sum?: TurmaSumAggregateInputType
    _min?: TurmaMinAggregateInputType
    _max?: TurmaMaxAggregateInputType
  }

  export type TurmaGroupByOutputType = {
    id: number
    nome: string
    escolaId: number
    anoEscolarId: number
    criadoEm: Date
    atualizadoEm: Date
    _count: TurmaCountAggregateOutputType | null
    _avg: TurmaAvgAggregateOutputType | null
    _sum: TurmaSumAggregateOutputType | null
    _min: TurmaMinAggregateOutputType | null
    _max: TurmaMaxAggregateOutputType | null
  }

  type GetTurmaGroupByPayload<T extends TurmaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TurmaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TurmaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TurmaGroupByOutputType[P]>
            : GetScalarType<T[P], TurmaGroupByOutputType[P]>
        }
      >
    >


  export type TurmaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    escolaId?: boolean
    anoEscolarId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    anoEscolar?: boolean | AnoEscolarDefaultArgs<ExtArgs>
    alunos?: boolean | Turma$alunosArgs<ExtArgs>
    _count?: boolean | TurmaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["turma"]>

  export type TurmaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    escolaId?: boolean
    anoEscolarId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    anoEscolar?: boolean | AnoEscolarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["turma"]>

  export type TurmaSelectScalar = {
    id?: boolean
    nome?: boolean
    escolaId?: boolean
    anoEscolarId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type TurmaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    anoEscolar?: boolean | AnoEscolarDefaultArgs<ExtArgs>
    alunos?: boolean | Turma$alunosArgs<ExtArgs>
    _count?: boolean | TurmaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TurmaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    anoEscolar?: boolean | AnoEscolarDefaultArgs<ExtArgs>
  }

  export type $TurmaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Turma"
    objects: {
      escola: Prisma.$EscolaPayload<ExtArgs>
      anoEscolar: Prisma.$AnoEscolarPayload<ExtArgs>
      alunos: Prisma.$AlunoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      escolaId: number
      anoEscolarId: number
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["turma"]>
    composites: {}
  }

  type TurmaGetPayload<S extends boolean | null | undefined | TurmaDefaultArgs> = $Result.GetResult<Prisma.$TurmaPayload, S>

  type TurmaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TurmaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TurmaCountAggregateInputType | true
    }

  export interface TurmaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Turma'], meta: { name: 'Turma' } }
    /**
     * Find zero or one Turma that matches the filter.
     * @param {TurmaFindUniqueArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TurmaFindUniqueArgs>(args: SelectSubset<T, TurmaFindUniqueArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Turma that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TurmaFindUniqueOrThrowArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TurmaFindUniqueOrThrowArgs>(args: SelectSubset<T, TurmaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Turma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaFindFirstArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TurmaFindFirstArgs>(args?: SelectSubset<T, TurmaFindFirstArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Turma that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaFindFirstOrThrowArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TurmaFindFirstOrThrowArgs>(args?: SelectSubset<T, TurmaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Turmas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Turmas
     * const turmas = await prisma.turma.findMany()
     * 
     * // Get first 10 Turmas
     * const turmas = await prisma.turma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const turmaWithIdOnly = await prisma.turma.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TurmaFindManyArgs>(args?: SelectSubset<T, TurmaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Turma.
     * @param {TurmaCreateArgs} args - Arguments to create a Turma.
     * @example
     * // Create one Turma
     * const Turma = await prisma.turma.create({
     *   data: {
     *     // ... data to create a Turma
     *   }
     * })
     * 
     */
    create<T extends TurmaCreateArgs>(args: SelectSubset<T, TurmaCreateArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Turmas.
     * @param {TurmaCreateManyArgs} args - Arguments to create many Turmas.
     * @example
     * // Create many Turmas
     * const turma = await prisma.turma.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TurmaCreateManyArgs>(args?: SelectSubset<T, TurmaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Turmas and returns the data saved in the database.
     * @param {TurmaCreateManyAndReturnArgs} args - Arguments to create many Turmas.
     * @example
     * // Create many Turmas
     * const turma = await prisma.turma.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Turmas and only return the `id`
     * const turmaWithIdOnly = await prisma.turma.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TurmaCreateManyAndReturnArgs>(args?: SelectSubset<T, TurmaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Turma.
     * @param {TurmaDeleteArgs} args - Arguments to delete one Turma.
     * @example
     * // Delete one Turma
     * const Turma = await prisma.turma.delete({
     *   where: {
     *     // ... filter to delete one Turma
     *   }
     * })
     * 
     */
    delete<T extends TurmaDeleteArgs>(args: SelectSubset<T, TurmaDeleteArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Turma.
     * @param {TurmaUpdateArgs} args - Arguments to update one Turma.
     * @example
     * // Update one Turma
     * const turma = await prisma.turma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TurmaUpdateArgs>(args: SelectSubset<T, TurmaUpdateArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Turmas.
     * @param {TurmaDeleteManyArgs} args - Arguments to filter Turmas to delete.
     * @example
     * // Delete a few Turmas
     * const { count } = await prisma.turma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TurmaDeleteManyArgs>(args?: SelectSubset<T, TurmaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Turmas
     * const turma = await prisma.turma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TurmaUpdateManyArgs>(args: SelectSubset<T, TurmaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Turma.
     * @param {TurmaUpsertArgs} args - Arguments to update or create a Turma.
     * @example
     * // Update or create a Turma
     * const turma = await prisma.turma.upsert({
     *   create: {
     *     // ... data to create a Turma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Turma we want to update
     *   }
     * })
     */
    upsert<T extends TurmaUpsertArgs>(args: SelectSubset<T, TurmaUpsertArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaCountArgs} args - Arguments to filter Turmas to count.
     * @example
     * // Count the number of Turmas
     * const count = await prisma.turma.count({
     *   where: {
     *     // ... the filter for the Turmas we want to count
     *   }
     * })
    **/
    count<T extends TurmaCountArgs>(
      args?: Subset<T, TurmaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TurmaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Turma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TurmaAggregateArgs>(args: Subset<T, TurmaAggregateArgs>): Prisma.PrismaPromise<GetTurmaAggregateType<T>>

    /**
     * Group by Turma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TurmaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TurmaGroupByArgs['orderBy'] }
        : { orderBy?: TurmaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TurmaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTurmaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Turma model
   */
  readonly fields: TurmaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Turma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TurmaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    escola<T extends EscolaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscolaDefaultArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    anoEscolar<T extends AnoEscolarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnoEscolarDefaultArgs<ExtArgs>>): Prisma__AnoEscolarClient<$Result.GetResult<Prisma.$AnoEscolarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    alunos<T extends Turma$alunosArgs<ExtArgs> = {}>(args?: Subset<T, Turma$alunosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Turma model
   */ 
  interface TurmaFieldRefs {
    readonly id: FieldRef<"Turma", 'Int'>
    readonly nome: FieldRef<"Turma", 'String'>
    readonly escolaId: FieldRef<"Turma", 'Int'>
    readonly anoEscolarId: FieldRef<"Turma", 'Int'>
    readonly criadoEm: FieldRef<"Turma", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Turma", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Turma findUnique
   */
  export type TurmaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turma to fetch.
     */
    where: TurmaWhereUniqueInput
  }

  /**
   * Turma findUniqueOrThrow
   */
  export type TurmaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turma to fetch.
     */
    where: TurmaWhereUniqueInput
  }

  /**
   * Turma findFirst
   */
  export type TurmaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turma to fetch.
     */
    where?: TurmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turmas to fetch.
     */
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Turmas.
     */
    cursor?: TurmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Turmas.
     */
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }

  /**
   * Turma findFirstOrThrow
   */
  export type TurmaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turma to fetch.
     */
    where?: TurmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turmas to fetch.
     */
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Turmas.
     */
    cursor?: TurmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Turmas.
     */
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }

  /**
   * Turma findMany
   */
  export type TurmaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turmas to fetch.
     */
    where?: TurmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turmas to fetch.
     */
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Turmas.
     */
    cursor?: TurmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turmas.
     */
    skip?: number
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }

  /**
   * Turma create
   */
  export type TurmaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * The data needed to create a Turma.
     */
    data: XOR<TurmaCreateInput, TurmaUncheckedCreateInput>
  }

  /**
   * Turma createMany
   */
  export type TurmaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Turmas.
     */
    data: TurmaCreateManyInput | TurmaCreateManyInput[]
  }

  /**
   * Turma createManyAndReturn
   */
  export type TurmaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Turmas.
     */
    data: TurmaCreateManyInput | TurmaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Turma update
   */
  export type TurmaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * The data needed to update a Turma.
     */
    data: XOR<TurmaUpdateInput, TurmaUncheckedUpdateInput>
    /**
     * Choose, which Turma to update.
     */
    where: TurmaWhereUniqueInput
  }

  /**
   * Turma updateMany
   */
  export type TurmaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Turmas.
     */
    data: XOR<TurmaUpdateManyMutationInput, TurmaUncheckedUpdateManyInput>
    /**
     * Filter which Turmas to update
     */
    where?: TurmaWhereInput
  }

  /**
   * Turma upsert
   */
  export type TurmaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * The filter to search for the Turma to update in case it exists.
     */
    where: TurmaWhereUniqueInput
    /**
     * In case the Turma found by the `where` argument doesn't exist, create a new Turma with this data.
     */
    create: XOR<TurmaCreateInput, TurmaUncheckedCreateInput>
    /**
     * In case the Turma was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TurmaUpdateInput, TurmaUncheckedUpdateInput>
  }

  /**
   * Turma delete
   */
  export type TurmaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter which Turma to delete.
     */
    where: TurmaWhereUniqueInput
  }

  /**
   * Turma deleteMany
   */
  export type TurmaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Turmas to delete
     */
    where?: TurmaWhereInput
  }

  /**
   * Turma.alunos
   */
  export type Turma$alunosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    where?: AlunoWhereInput
    orderBy?: AlunoOrderByWithRelationInput | AlunoOrderByWithRelationInput[]
    cursor?: AlunoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * Turma without action
   */
  export type TurmaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TurmaInclude<ExtArgs> | null
  }


  /**
   * Model Aluno
   */

  export type AggregateAluno = {
    _count: AlunoCountAggregateOutputType | null
    _avg: AlunoAvgAggregateOutputType | null
    _sum: AlunoSumAggregateOutputType | null
    _min: AlunoMinAggregateOutputType | null
    _max: AlunoMaxAggregateOutputType | null
  }

  export type AlunoAvgAggregateOutputType = {
    id: number | null
    turmaId: number | null
  }

  export type AlunoSumAggregateOutputType = {
    id: number | null
    turmaId: number | null
  }

  export type AlunoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    dataNascimento: Date | null
    turmaId: number | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AlunoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    dataNascimento: Date | null
    turmaId: number | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AlunoCountAggregateOutputType = {
    id: number
    nome: number
    dataNascimento: number
    turmaId: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type AlunoAvgAggregateInputType = {
    id?: true
    turmaId?: true
  }

  export type AlunoSumAggregateInputType = {
    id?: true
    turmaId?: true
  }

  export type AlunoMinAggregateInputType = {
    id?: true
    nome?: true
    dataNascimento?: true
    turmaId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AlunoMaxAggregateInputType = {
    id?: true
    nome?: true
    dataNascimento?: true
    turmaId?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AlunoCountAggregateInputType = {
    id?: true
    nome?: true
    dataNascimento?: true
    turmaId?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type AlunoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Aluno to aggregate.
     */
    where?: AlunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alunos to fetch.
     */
    orderBy?: AlunoOrderByWithRelationInput | AlunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alunos
    **/
    _count?: true | AlunoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlunoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlunoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlunoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlunoMaxAggregateInputType
  }

  export type GetAlunoAggregateType<T extends AlunoAggregateArgs> = {
        [P in keyof T & keyof AggregateAluno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAluno[P]>
      : GetScalarType<T[P], AggregateAluno[P]>
  }




  export type AlunoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlunoWhereInput
    orderBy?: AlunoOrderByWithAggregationInput | AlunoOrderByWithAggregationInput[]
    by: AlunoScalarFieldEnum[] | AlunoScalarFieldEnum
    having?: AlunoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlunoCountAggregateInputType | true
    _avg?: AlunoAvgAggregateInputType
    _sum?: AlunoSumAggregateInputType
    _min?: AlunoMinAggregateInputType
    _max?: AlunoMaxAggregateInputType
  }

  export type AlunoGroupByOutputType = {
    id: number
    nome: string
    dataNascimento: Date | null
    turmaId: number
    criadoEm: Date
    atualizadoEm: Date
    _count: AlunoCountAggregateOutputType | null
    _avg: AlunoAvgAggregateOutputType | null
    _sum: AlunoSumAggregateOutputType | null
    _min: AlunoMinAggregateOutputType | null
    _max: AlunoMaxAggregateOutputType | null
  }

  type GetAlunoGroupByPayload<T extends AlunoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlunoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlunoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlunoGroupByOutputType[P]>
            : GetScalarType<T[P], AlunoGroupByOutputType[P]>
        }
      >
    >


  export type AlunoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dataNascimento?: boolean
    turmaId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    turma?: boolean | TurmaDefaultArgs<ExtArgs>
    avaliacoes?: boolean | Aluno$avaliacoesArgs<ExtArgs>
    _count?: boolean | AlunoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aluno"]>

  export type AlunoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dataNascimento?: boolean
    turmaId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    turma?: boolean | TurmaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aluno"]>

  export type AlunoSelectScalar = {
    id?: boolean
    nome?: boolean
    dataNascimento?: boolean
    turmaId?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type AlunoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    turma?: boolean | TurmaDefaultArgs<ExtArgs>
    avaliacoes?: boolean | Aluno$avaliacoesArgs<ExtArgs>
    _count?: boolean | AlunoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlunoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    turma?: boolean | TurmaDefaultArgs<ExtArgs>
  }

  export type $AlunoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Aluno"
    objects: {
      turma: Prisma.$TurmaPayload<ExtArgs>
      avaliacoes: Prisma.$AvaliacaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      dataNascimento: Date | null
      turmaId: number
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["aluno"]>
    composites: {}
  }

  type AlunoGetPayload<S extends boolean | null | undefined | AlunoDefaultArgs> = $Result.GetResult<Prisma.$AlunoPayload, S>

  type AlunoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlunoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlunoCountAggregateInputType | true
    }

  export interface AlunoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Aluno'], meta: { name: 'Aluno' } }
    /**
     * Find zero or one Aluno that matches the filter.
     * @param {AlunoFindUniqueArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlunoFindUniqueArgs>(args: SelectSubset<T, AlunoFindUniqueArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Aluno that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlunoFindUniqueOrThrowArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlunoFindUniqueOrThrowArgs>(args: SelectSubset<T, AlunoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Aluno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoFindFirstArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlunoFindFirstArgs>(args?: SelectSubset<T, AlunoFindFirstArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Aluno that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoFindFirstOrThrowArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlunoFindFirstOrThrowArgs>(args?: SelectSubset<T, AlunoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alunos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alunos
     * const alunos = await prisma.aluno.findMany()
     * 
     * // Get first 10 Alunos
     * const alunos = await prisma.aluno.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alunoWithIdOnly = await prisma.aluno.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlunoFindManyArgs>(args?: SelectSubset<T, AlunoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Aluno.
     * @param {AlunoCreateArgs} args - Arguments to create a Aluno.
     * @example
     * // Create one Aluno
     * const Aluno = await prisma.aluno.create({
     *   data: {
     *     // ... data to create a Aluno
     *   }
     * })
     * 
     */
    create<T extends AlunoCreateArgs>(args: SelectSubset<T, AlunoCreateArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alunos.
     * @param {AlunoCreateManyArgs} args - Arguments to create many Alunos.
     * @example
     * // Create many Alunos
     * const aluno = await prisma.aluno.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlunoCreateManyArgs>(args?: SelectSubset<T, AlunoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alunos and returns the data saved in the database.
     * @param {AlunoCreateManyAndReturnArgs} args - Arguments to create many Alunos.
     * @example
     * // Create many Alunos
     * const aluno = await prisma.aluno.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alunos and only return the `id`
     * const alunoWithIdOnly = await prisma.aluno.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlunoCreateManyAndReturnArgs>(args?: SelectSubset<T, AlunoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Aluno.
     * @param {AlunoDeleteArgs} args - Arguments to delete one Aluno.
     * @example
     * // Delete one Aluno
     * const Aluno = await prisma.aluno.delete({
     *   where: {
     *     // ... filter to delete one Aluno
     *   }
     * })
     * 
     */
    delete<T extends AlunoDeleteArgs>(args: SelectSubset<T, AlunoDeleteArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Aluno.
     * @param {AlunoUpdateArgs} args - Arguments to update one Aluno.
     * @example
     * // Update one Aluno
     * const aluno = await prisma.aluno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlunoUpdateArgs>(args: SelectSubset<T, AlunoUpdateArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alunos.
     * @param {AlunoDeleteManyArgs} args - Arguments to filter Alunos to delete.
     * @example
     * // Delete a few Alunos
     * const { count } = await prisma.aluno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlunoDeleteManyArgs>(args?: SelectSubset<T, AlunoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alunos
     * const aluno = await prisma.aluno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlunoUpdateManyArgs>(args: SelectSubset<T, AlunoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Aluno.
     * @param {AlunoUpsertArgs} args - Arguments to update or create a Aluno.
     * @example
     * // Update or create a Aluno
     * const aluno = await prisma.aluno.upsert({
     *   create: {
     *     // ... data to create a Aluno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aluno we want to update
     *   }
     * })
     */
    upsert<T extends AlunoUpsertArgs>(args: SelectSubset<T, AlunoUpsertArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoCountArgs} args - Arguments to filter Alunos to count.
     * @example
     * // Count the number of Alunos
     * const count = await prisma.aluno.count({
     *   where: {
     *     // ... the filter for the Alunos we want to count
     *   }
     * })
    **/
    count<T extends AlunoCountArgs>(
      args?: Subset<T, AlunoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlunoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aluno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlunoAggregateArgs>(args: Subset<T, AlunoAggregateArgs>): Prisma.PrismaPromise<GetAlunoAggregateType<T>>

    /**
     * Group by Aluno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlunoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlunoGroupByArgs['orderBy'] }
        : { orderBy?: AlunoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlunoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlunoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Aluno model
   */
  readonly fields: AlunoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Aluno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlunoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    turma<T extends TurmaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TurmaDefaultArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    avaliacoes<T extends Aluno$avaliacoesArgs<ExtArgs> = {}>(args?: Subset<T, Aluno$avaliacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Aluno model
   */ 
  interface AlunoFieldRefs {
    readonly id: FieldRef<"Aluno", 'Int'>
    readonly nome: FieldRef<"Aluno", 'String'>
    readonly dataNascimento: FieldRef<"Aluno", 'DateTime'>
    readonly turmaId: FieldRef<"Aluno", 'Int'>
    readonly criadoEm: FieldRef<"Aluno", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Aluno", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Aluno findUnique
   */
  export type AlunoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    /**
     * Filter, which Aluno to fetch.
     */
    where: AlunoWhereUniqueInput
  }

  /**
   * Aluno findUniqueOrThrow
   */
  export type AlunoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    /**
     * Filter, which Aluno to fetch.
     */
    where: AlunoWhereUniqueInput
  }

  /**
   * Aluno findFirst
   */
  export type AlunoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    /**
     * Filter, which Aluno to fetch.
     */
    where?: AlunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alunos to fetch.
     */
    orderBy?: AlunoOrderByWithRelationInput | AlunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alunos.
     */
    cursor?: AlunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alunos.
     */
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * Aluno findFirstOrThrow
   */
  export type AlunoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    /**
     * Filter, which Aluno to fetch.
     */
    where?: AlunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alunos to fetch.
     */
    orderBy?: AlunoOrderByWithRelationInput | AlunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alunos.
     */
    cursor?: AlunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alunos.
     */
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * Aluno findMany
   */
  export type AlunoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    /**
     * Filter, which Alunos to fetch.
     */
    where?: AlunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alunos to fetch.
     */
    orderBy?: AlunoOrderByWithRelationInput | AlunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alunos.
     */
    cursor?: AlunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alunos.
     */
    skip?: number
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * Aluno create
   */
  export type AlunoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    /**
     * The data needed to create a Aluno.
     */
    data: XOR<AlunoCreateInput, AlunoUncheckedCreateInput>
  }

  /**
   * Aluno createMany
   */
  export type AlunoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alunos.
     */
    data: AlunoCreateManyInput | AlunoCreateManyInput[]
  }

  /**
   * Aluno createManyAndReturn
   */
  export type AlunoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alunos.
     */
    data: AlunoCreateManyInput | AlunoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Aluno update
   */
  export type AlunoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    /**
     * The data needed to update a Aluno.
     */
    data: XOR<AlunoUpdateInput, AlunoUncheckedUpdateInput>
    /**
     * Choose, which Aluno to update.
     */
    where: AlunoWhereUniqueInput
  }

  /**
   * Aluno updateMany
   */
  export type AlunoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alunos.
     */
    data: XOR<AlunoUpdateManyMutationInput, AlunoUncheckedUpdateManyInput>
    /**
     * Filter which Alunos to update
     */
    where?: AlunoWhereInput
  }

  /**
   * Aluno upsert
   */
  export type AlunoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    /**
     * The filter to search for the Aluno to update in case it exists.
     */
    where: AlunoWhereUniqueInput
    /**
     * In case the Aluno found by the `where` argument doesn't exist, create a new Aluno with this data.
     */
    create: XOR<AlunoCreateInput, AlunoUncheckedCreateInput>
    /**
     * In case the Aluno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlunoUpdateInput, AlunoUncheckedUpdateInput>
  }

  /**
   * Aluno delete
   */
  export type AlunoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
    /**
     * Filter which Aluno to delete.
     */
    where: AlunoWhereUniqueInput
  }

  /**
   * Aluno deleteMany
   */
  export type AlunoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alunos to delete
     */
    where?: AlunoWhereInput
  }

  /**
   * Aluno.avaliacoes
   */
  export type Aluno$avaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Aluno without action
   */
  export type AlunoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlunoInclude<ExtArgs> | null
  }


  /**
   * Model EventoAvaliacao
   */

  export type AggregateEventoAvaliacao = {
    _count: EventoAvaliacaoCountAggregateOutputType | null
    _avg: EventoAvaliacaoAvgAggregateOutputType | null
    _sum: EventoAvaliacaoSumAggregateOutputType | null
    _min: EventoAvaliacaoMinAggregateOutputType | null
    _max: EventoAvaliacaoMaxAggregateOutputType | null
  }

  export type EventoAvaliacaoAvgAggregateOutputType = {
    id: number | null
  }

  export type EventoAvaliacaoSumAggregateOutputType = {
    id: number | null
  }

  export type EventoAvaliacaoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    dataInicio: Date | null
    dataFim: Date | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type EventoAvaliacaoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    dataInicio: Date | null
    dataFim: Date | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type EventoAvaliacaoCountAggregateOutputType = {
    id: number
    nome: number
    dataInicio: number
    dataFim: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type EventoAvaliacaoAvgAggregateInputType = {
    id?: true
  }

  export type EventoAvaliacaoSumAggregateInputType = {
    id?: true
  }

  export type EventoAvaliacaoMinAggregateInputType = {
    id?: true
    nome?: true
    dataInicio?: true
    dataFim?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type EventoAvaliacaoMaxAggregateInputType = {
    id?: true
    nome?: true
    dataInicio?: true
    dataFim?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type EventoAvaliacaoCountAggregateInputType = {
    id?: true
    nome?: true
    dataInicio?: true
    dataFim?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type EventoAvaliacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventoAvaliacao to aggregate.
     */
    where?: EventoAvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventoAvaliacaos to fetch.
     */
    orderBy?: EventoAvaliacaoOrderByWithRelationInput | EventoAvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventoAvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventoAvaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventoAvaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventoAvaliacaos
    **/
    _count?: true | EventoAvaliacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventoAvaliacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventoAvaliacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventoAvaliacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventoAvaliacaoMaxAggregateInputType
  }

  export type GetEventoAvaliacaoAggregateType<T extends EventoAvaliacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateEventoAvaliacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventoAvaliacao[P]>
      : GetScalarType<T[P], AggregateEventoAvaliacao[P]>
  }




  export type EventoAvaliacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoAvaliacaoWhereInput
    orderBy?: EventoAvaliacaoOrderByWithAggregationInput | EventoAvaliacaoOrderByWithAggregationInput[]
    by: EventoAvaliacaoScalarFieldEnum[] | EventoAvaliacaoScalarFieldEnum
    having?: EventoAvaliacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventoAvaliacaoCountAggregateInputType | true
    _avg?: EventoAvaliacaoAvgAggregateInputType
    _sum?: EventoAvaliacaoSumAggregateInputType
    _min?: EventoAvaliacaoMinAggregateInputType
    _max?: EventoAvaliacaoMaxAggregateInputType
  }

  export type EventoAvaliacaoGroupByOutputType = {
    id: number
    nome: string
    dataInicio: Date
    dataFim: Date
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: EventoAvaliacaoCountAggregateOutputType | null
    _avg: EventoAvaliacaoAvgAggregateOutputType | null
    _sum: EventoAvaliacaoSumAggregateOutputType | null
    _min: EventoAvaliacaoMinAggregateOutputType | null
    _max: EventoAvaliacaoMaxAggregateOutputType | null
  }

  type GetEventoAvaliacaoGroupByPayload<T extends EventoAvaliacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventoAvaliacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventoAvaliacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventoAvaliacaoGroupByOutputType[P]>
            : GetScalarType<T[P], EventoAvaliacaoGroupByOutputType[P]>
        }
      >
    >


  export type EventoAvaliacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dataInicio?: boolean
    dataFim?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    avaliacoes?: boolean | EventoAvaliacao$avaliacoesArgs<ExtArgs>
    _count?: boolean | EventoAvaliacaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventoAvaliacao"]>

  export type EventoAvaliacaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dataInicio?: boolean
    dataFim?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["eventoAvaliacao"]>

  export type EventoAvaliacaoSelectScalar = {
    id?: boolean
    nome?: boolean
    dataInicio?: boolean
    dataFim?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type EventoAvaliacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avaliacoes?: boolean | EventoAvaliacao$avaliacoesArgs<ExtArgs>
    _count?: boolean | EventoAvaliacaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventoAvaliacaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventoAvaliacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventoAvaliacao"
    objects: {
      avaliacoes: Prisma.$AvaliacaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      dataInicio: Date
      dataFim: Date
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["eventoAvaliacao"]>
    composites: {}
  }

  type EventoAvaliacaoGetPayload<S extends boolean | null | undefined | EventoAvaliacaoDefaultArgs> = $Result.GetResult<Prisma.$EventoAvaliacaoPayload, S>

  type EventoAvaliacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventoAvaliacaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventoAvaliacaoCountAggregateInputType | true
    }

  export interface EventoAvaliacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventoAvaliacao'], meta: { name: 'EventoAvaliacao' } }
    /**
     * Find zero or one EventoAvaliacao that matches the filter.
     * @param {EventoAvaliacaoFindUniqueArgs} args - Arguments to find a EventoAvaliacao
     * @example
     * // Get one EventoAvaliacao
     * const eventoAvaliacao = await prisma.eventoAvaliacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventoAvaliacaoFindUniqueArgs>(args: SelectSubset<T, EventoAvaliacaoFindUniqueArgs<ExtArgs>>): Prisma__EventoAvaliacaoClient<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventoAvaliacao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventoAvaliacaoFindUniqueOrThrowArgs} args - Arguments to find a EventoAvaliacao
     * @example
     * // Get one EventoAvaliacao
     * const eventoAvaliacao = await prisma.eventoAvaliacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventoAvaliacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, EventoAvaliacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventoAvaliacaoClient<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventoAvaliacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAvaliacaoFindFirstArgs} args - Arguments to find a EventoAvaliacao
     * @example
     * // Get one EventoAvaliacao
     * const eventoAvaliacao = await prisma.eventoAvaliacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventoAvaliacaoFindFirstArgs>(args?: SelectSubset<T, EventoAvaliacaoFindFirstArgs<ExtArgs>>): Prisma__EventoAvaliacaoClient<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventoAvaliacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAvaliacaoFindFirstOrThrowArgs} args - Arguments to find a EventoAvaliacao
     * @example
     * // Get one EventoAvaliacao
     * const eventoAvaliacao = await prisma.eventoAvaliacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventoAvaliacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, EventoAvaliacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventoAvaliacaoClient<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventoAvaliacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAvaliacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventoAvaliacaos
     * const eventoAvaliacaos = await prisma.eventoAvaliacao.findMany()
     * 
     * // Get first 10 EventoAvaliacaos
     * const eventoAvaliacaos = await prisma.eventoAvaliacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventoAvaliacaoWithIdOnly = await prisma.eventoAvaliacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventoAvaliacaoFindManyArgs>(args?: SelectSubset<T, EventoAvaliacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventoAvaliacao.
     * @param {EventoAvaliacaoCreateArgs} args - Arguments to create a EventoAvaliacao.
     * @example
     * // Create one EventoAvaliacao
     * const EventoAvaliacao = await prisma.eventoAvaliacao.create({
     *   data: {
     *     // ... data to create a EventoAvaliacao
     *   }
     * })
     * 
     */
    create<T extends EventoAvaliacaoCreateArgs>(args: SelectSubset<T, EventoAvaliacaoCreateArgs<ExtArgs>>): Prisma__EventoAvaliacaoClient<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventoAvaliacaos.
     * @param {EventoAvaliacaoCreateManyArgs} args - Arguments to create many EventoAvaliacaos.
     * @example
     * // Create many EventoAvaliacaos
     * const eventoAvaliacao = await prisma.eventoAvaliacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventoAvaliacaoCreateManyArgs>(args?: SelectSubset<T, EventoAvaliacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventoAvaliacaos and returns the data saved in the database.
     * @param {EventoAvaliacaoCreateManyAndReturnArgs} args - Arguments to create many EventoAvaliacaos.
     * @example
     * // Create many EventoAvaliacaos
     * const eventoAvaliacao = await prisma.eventoAvaliacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventoAvaliacaos and only return the `id`
     * const eventoAvaliacaoWithIdOnly = await prisma.eventoAvaliacao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventoAvaliacaoCreateManyAndReturnArgs>(args?: SelectSubset<T, EventoAvaliacaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventoAvaliacao.
     * @param {EventoAvaliacaoDeleteArgs} args - Arguments to delete one EventoAvaliacao.
     * @example
     * // Delete one EventoAvaliacao
     * const EventoAvaliacao = await prisma.eventoAvaliacao.delete({
     *   where: {
     *     // ... filter to delete one EventoAvaliacao
     *   }
     * })
     * 
     */
    delete<T extends EventoAvaliacaoDeleteArgs>(args: SelectSubset<T, EventoAvaliacaoDeleteArgs<ExtArgs>>): Prisma__EventoAvaliacaoClient<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventoAvaliacao.
     * @param {EventoAvaliacaoUpdateArgs} args - Arguments to update one EventoAvaliacao.
     * @example
     * // Update one EventoAvaliacao
     * const eventoAvaliacao = await prisma.eventoAvaliacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventoAvaliacaoUpdateArgs>(args: SelectSubset<T, EventoAvaliacaoUpdateArgs<ExtArgs>>): Prisma__EventoAvaliacaoClient<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventoAvaliacaos.
     * @param {EventoAvaliacaoDeleteManyArgs} args - Arguments to filter EventoAvaliacaos to delete.
     * @example
     * // Delete a few EventoAvaliacaos
     * const { count } = await prisma.eventoAvaliacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventoAvaliacaoDeleteManyArgs>(args?: SelectSubset<T, EventoAvaliacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventoAvaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAvaliacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventoAvaliacaos
     * const eventoAvaliacao = await prisma.eventoAvaliacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventoAvaliacaoUpdateManyArgs>(args: SelectSubset<T, EventoAvaliacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventoAvaliacao.
     * @param {EventoAvaliacaoUpsertArgs} args - Arguments to update or create a EventoAvaliacao.
     * @example
     * // Update or create a EventoAvaliacao
     * const eventoAvaliacao = await prisma.eventoAvaliacao.upsert({
     *   create: {
     *     // ... data to create a EventoAvaliacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventoAvaliacao we want to update
     *   }
     * })
     */
    upsert<T extends EventoAvaliacaoUpsertArgs>(args: SelectSubset<T, EventoAvaliacaoUpsertArgs<ExtArgs>>): Prisma__EventoAvaliacaoClient<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventoAvaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAvaliacaoCountArgs} args - Arguments to filter EventoAvaliacaos to count.
     * @example
     * // Count the number of EventoAvaliacaos
     * const count = await prisma.eventoAvaliacao.count({
     *   where: {
     *     // ... the filter for the EventoAvaliacaos we want to count
     *   }
     * })
    **/
    count<T extends EventoAvaliacaoCountArgs>(
      args?: Subset<T, EventoAvaliacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventoAvaliacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventoAvaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAvaliacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventoAvaliacaoAggregateArgs>(args: Subset<T, EventoAvaliacaoAggregateArgs>): Prisma.PrismaPromise<GetEventoAvaliacaoAggregateType<T>>

    /**
     * Group by EventoAvaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAvaliacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventoAvaliacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventoAvaliacaoGroupByArgs['orderBy'] }
        : { orderBy?: EventoAvaliacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventoAvaliacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventoAvaliacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventoAvaliacao model
   */
  readonly fields: EventoAvaliacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventoAvaliacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventoAvaliacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avaliacoes<T extends EventoAvaliacao$avaliacoesArgs<ExtArgs> = {}>(args?: Subset<T, EventoAvaliacao$avaliacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventoAvaliacao model
   */ 
  interface EventoAvaliacaoFieldRefs {
    readonly id: FieldRef<"EventoAvaliacao", 'Int'>
    readonly nome: FieldRef<"EventoAvaliacao", 'String'>
    readonly dataInicio: FieldRef<"EventoAvaliacao", 'DateTime'>
    readonly dataFim: FieldRef<"EventoAvaliacao", 'DateTime'>
    readonly ativo: FieldRef<"EventoAvaliacao", 'Boolean'>
    readonly criadoEm: FieldRef<"EventoAvaliacao", 'DateTime'>
    readonly atualizadoEm: FieldRef<"EventoAvaliacao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventoAvaliacao findUnique
   */
  export type EventoAvaliacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which EventoAvaliacao to fetch.
     */
    where: EventoAvaliacaoWhereUniqueInput
  }

  /**
   * EventoAvaliacao findUniqueOrThrow
   */
  export type EventoAvaliacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which EventoAvaliacao to fetch.
     */
    where: EventoAvaliacaoWhereUniqueInput
  }

  /**
   * EventoAvaliacao findFirst
   */
  export type EventoAvaliacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which EventoAvaliacao to fetch.
     */
    where?: EventoAvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventoAvaliacaos to fetch.
     */
    orderBy?: EventoAvaliacaoOrderByWithRelationInput | EventoAvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventoAvaliacaos.
     */
    cursor?: EventoAvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventoAvaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventoAvaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventoAvaliacaos.
     */
    distinct?: EventoAvaliacaoScalarFieldEnum | EventoAvaliacaoScalarFieldEnum[]
  }

  /**
   * EventoAvaliacao findFirstOrThrow
   */
  export type EventoAvaliacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which EventoAvaliacao to fetch.
     */
    where?: EventoAvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventoAvaliacaos to fetch.
     */
    orderBy?: EventoAvaliacaoOrderByWithRelationInput | EventoAvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventoAvaliacaos.
     */
    cursor?: EventoAvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventoAvaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventoAvaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventoAvaliacaos.
     */
    distinct?: EventoAvaliacaoScalarFieldEnum | EventoAvaliacaoScalarFieldEnum[]
  }

  /**
   * EventoAvaliacao findMany
   */
  export type EventoAvaliacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which EventoAvaliacaos to fetch.
     */
    where?: EventoAvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventoAvaliacaos to fetch.
     */
    orderBy?: EventoAvaliacaoOrderByWithRelationInput | EventoAvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventoAvaliacaos.
     */
    cursor?: EventoAvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventoAvaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventoAvaliacaos.
     */
    skip?: number
    distinct?: EventoAvaliacaoScalarFieldEnum | EventoAvaliacaoScalarFieldEnum[]
  }

  /**
   * EventoAvaliacao create
   */
  export type EventoAvaliacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a EventoAvaliacao.
     */
    data: XOR<EventoAvaliacaoCreateInput, EventoAvaliacaoUncheckedCreateInput>
  }

  /**
   * EventoAvaliacao createMany
   */
  export type EventoAvaliacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventoAvaliacaos.
     */
    data: EventoAvaliacaoCreateManyInput | EventoAvaliacaoCreateManyInput[]
  }

  /**
   * EventoAvaliacao createManyAndReturn
   */
  export type EventoAvaliacaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventoAvaliacaos.
     */
    data: EventoAvaliacaoCreateManyInput | EventoAvaliacaoCreateManyInput[]
  }

  /**
   * EventoAvaliacao update
   */
  export type EventoAvaliacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a EventoAvaliacao.
     */
    data: XOR<EventoAvaliacaoUpdateInput, EventoAvaliacaoUncheckedUpdateInput>
    /**
     * Choose, which EventoAvaliacao to update.
     */
    where: EventoAvaliacaoWhereUniqueInput
  }

  /**
   * EventoAvaliacao updateMany
   */
  export type EventoAvaliacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventoAvaliacaos.
     */
    data: XOR<EventoAvaliacaoUpdateManyMutationInput, EventoAvaliacaoUncheckedUpdateManyInput>
    /**
     * Filter which EventoAvaliacaos to update
     */
    where?: EventoAvaliacaoWhereInput
  }

  /**
   * EventoAvaliacao upsert
   */
  export type EventoAvaliacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the EventoAvaliacao to update in case it exists.
     */
    where: EventoAvaliacaoWhereUniqueInput
    /**
     * In case the EventoAvaliacao found by the `where` argument doesn't exist, create a new EventoAvaliacao with this data.
     */
    create: XOR<EventoAvaliacaoCreateInput, EventoAvaliacaoUncheckedCreateInput>
    /**
     * In case the EventoAvaliacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventoAvaliacaoUpdateInput, EventoAvaliacaoUncheckedUpdateInput>
  }

  /**
   * EventoAvaliacao delete
   */
  export type EventoAvaliacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
    /**
     * Filter which EventoAvaliacao to delete.
     */
    where: EventoAvaliacaoWhereUniqueInput
  }

  /**
   * EventoAvaliacao deleteMany
   */
  export type EventoAvaliacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventoAvaliacaos to delete
     */
    where?: EventoAvaliacaoWhereInput
  }

  /**
   * EventoAvaliacao.avaliacoes
   */
  export type EventoAvaliacao$avaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * EventoAvaliacao without action
   */
  export type EventoAvaliacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAvaliacao
     */
    select?: EventoAvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAvaliacaoInclude<ExtArgs> | null
  }


  /**
   * Model Avaliacao
   */

  export type AggregateAvaliacao = {
    _count: AvaliacaoCountAggregateOutputType | null
    _avg: AvaliacaoAvgAggregateOutputType | null
    _sum: AvaliacaoSumAggregateOutputType | null
    _min: AvaliacaoMinAggregateOutputType | null
    _max: AvaliacaoMaxAggregateOutputType | null
  }

  export type AvaliacaoAvgAggregateOutputType = {
    id: number | null
    alunoId: number | null
    eventoId: number | null
    aplicadorId: number | null
    palavrasPorMinuto: number | null
    precisao: number | null
    fluencia: number | null
    compreensao: number | null
  }

  export type AvaliacaoSumAggregateOutputType = {
    id: number | null
    alunoId: number | null
    eventoId: number | null
    aplicadorId: number | null
    palavrasPorMinuto: number | null
    precisao: number | null
    fluencia: number | null
    compreensao: number | null
  }

  export type AvaliacaoMinAggregateOutputType = {
    id: number | null
    alunoId: number | null
    eventoId: number | null
    aplicadorId: number | null
    palavrasPorMinuto: number | null
    precisao: number | null
    fluencia: number | null
    compreensao: number | null
    nivelLeitura: string | null
    observacoes: string | null
    dataAvaliacao: Date | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AvaliacaoMaxAggregateOutputType = {
    id: number | null
    alunoId: number | null
    eventoId: number | null
    aplicadorId: number | null
    palavrasPorMinuto: number | null
    precisao: number | null
    fluencia: number | null
    compreensao: number | null
    nivelLeitura: string | null
    observacoes: string | null
    dataAvaliacao: Date | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AvaliacaoCountAggregateOutputType = {
    id: number
    alunoId: number
    eventoId: number
    aplicadorId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: number
    observacoes: number
    dataAvaliacao: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type AvaliacaoAvgAggregateInputType = {
    id?: true
    alunoId?: true
    eventoId?: true
    aplicadorId?: true
    palavrasPorMinuto?: true
    precisao?: true
    fluencia?: true
    compreensao?: true
  }

  export type AvaliacaoSumAggregateInputType = {
    id?: true
    alunoId?: true
    eventoId?: true
    aplicadorId?: true
    palavrasPorMinuto?: true
    precisao?: true
    fluencia?: true
    compreensao?: true
  }

  export type AvaliacaoMinAggregateInputType = {
    id?: true
    alunoId?: true
    eventoId?: true
    aplicadorId?: true
    palavrasPorMinuto?: true
    precisao?: true
    fluencia?: true
    compreensao?: true
    nivelLeitura?: true
    observacoes?: true
    dataAvaliacao?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AvaliacaoMaxAggregateInputType = {
    id?: true
    alunoId?: true
    eventoId?: true
    aplicadorId?: true
    palavrasPorMinuto?: true
    precisao?: true
    fluencia?: true
    compreensao?: true
    nivelLeitura?: true
    observacoes?: true
    dataAvaliacao?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AvaliacaoCountAggregateInputType = {
    id?: true
    alunoId?: true
    eventoId?: true
    aplicadorId?: true
    palavrasPorMinuto?: true
    precisao?: true
    fluencia?: true
    compreensao?: true
    nivelLeitura?: true
    observacoes?: true
    dataAvaliacao?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type AvaliacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avaliacao to aggregate.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Avaliacaos
    **/
    _count?: true | AvaliacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvaliacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvaliacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvaliacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvaliacaoMaxAggregateInputType
  }

  export type GetAvaliacaoAggregateType<T extends AvaliacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateAvaliacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvaliacao[P]>
      : GetScalarType<T[P], AggregateAvaliacao[P]>
  }




  export type AvaliacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithAggregationInput | AvaliacaoOrderByWithAggregationInput[]
    by: AvaliacaoScalarFieldEnum[] | AvaliacaoScalarFieldEnum
    having?: AvaliacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvaliacaoCountAggregateInputType | true
    _avg?: AvaliacaoAvgAggregateInputType
    _sum?: AvaliacaoSumAggregateInputType
    _min?: AvaliacaoMinAggregateInputType
    _max?: AvaliacaoMaxAggregateInputType
  }

  export type AvaliacaoGroupByOutputType = {
    id: number
    alunoId: number
    eventoId: number
    aplicadorId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes: string | null
    dataAvaliacao: Date
    criadoEm: Date
    atualizadoEm: Date
    _count: AvaliacaoCountAggregateOutputType | null
    _avg: AvaliacaoAvgAggregateOutputType | null
    _sum: AvaliacaoSumAggregateOutputType | null
    _min: AvaliacaoMinAggregateOutputType | null
    _max: AvaliacaoMaxAggregateOutputType | null
  }

  type GetAvaliacaoGroupByPayload<T extends AvaliacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvaliacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvaliacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>
            : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>
        }
      >
    >


  export type AvaliacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alunoId?: boolean
    eventoId?: boolean
    aplicadorId?: boolean
    palavrasPorMinuto?: boolean
    precisao?: boolean
    fluencia?: boolean
    compreensao?: boolean
    nivelLeitura?: boolean
    observacoes?: boolean
    dataAvaliacao?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    aluno?: boolean | AlunoDefaultArgs<ExtArgs>
    evento?: boolean | EventoAvaliacaoDefaultArgs<ExtArgs>
    aplicador?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alunoId?: boolean
    eventoId?: boolean
    aplicadorId?: boolean
    palavrasPorMinuto?: boolean
    precisao?: boolean
    fluencia?: boolean
    compreensao?: boolean
    nivelLeitura?: boolean
    observacoes?: boolean
    dataAvaliacao?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    aluno?: boolean | AlunoDefaultArgs<ExtArgs>
    evento?: boolean | EventoAvaliacaoDefaultArgs<ExtArgs>
    aplicador?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectScalar = {
    id?: boolean
    alunoId?: boolean
    eventoId?: boolean
    aplicadorId?: boolean
    palavrasPorMinuto?: boolean
    precisao?: boolean
    fluencia?: boolean
    compreensao?: boolean
    nivelLeitura?: boolean
    observacoes?: boolean
    dataAvaliacao?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type AvaliacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aluno?: boolean | AlunoDefaultArgs<ExtArgs>
    evento?: boolean | EventoAvaliacaoDefaultArgs<ExtArgs>
    aplicador?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type AvaliacaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aluno?: boolean | AlunoDefaultArgs<ExtArgs>
    evento?: boolean | EventoAvaliacaoDefaultArgs<ExtArgs>
    aplicador?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $AvaliacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Avaliacao"
    objects: {
      aluno: Prisma.$AlunoPayload<ExtArgs>
      evento: Prisma.$EventoAvaliacaoPayload<ExtArgs>
      aplicador: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alunoId: number
      eventoId: number
      aplicadorId: number
      palavrasPorMinuto: number
      precisao: number
      fluencia: number
      compreensao: number
      nivelLeitura: string
      observacoes: string | null
      dataAvaliacao: Date
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["avaliacao"]>
    composites: {}
  }

  type AvaliacaoGetPayload<S extends boolean | null | undefined | AvaliacaoDefaultArgs> = $Result.GetResult<Prisma.$AvaliacaoPayload, S>

  type AvaliacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AvaliacaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AvaliacaoCountAggregateInputType | true
    }

  export interface AvaliacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Avaliacao'], meta: { name: 'Avaliacao' } }
    /**
     * Find zero or one Avaliacao that matches the filter.
     * @param {AvaliacaoFindUniqueArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvaliacaoFindUniqueArgs>(args: SelectSubset<T, AvaliacaoFindUniqueArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Avaliacao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AvaliacaoFindUniqueOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvaliacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, AvaliacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Avaliacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindFirstArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvaliacaoFindFirstArgs>(args?: SelectSubset<T, AvaliacaoFindFirstArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Avaliacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindFirstOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvaliacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, AvaliacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Avaliacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany()
     * 
     * // Get first 10 Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avaliacaoWithIdOnly = await prisma.avaliacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvaliacaoFindManyArgs>(args?: SelectSubset<T, AvaliacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Avaliacao.
     * @param {AvaliacaoCreateArgs} args - Arguments to create a Avaliacao.
     * @example
     * // Create one Avaliacao
     * const Avaliacao = await prisma.avaliacao.create({
     *   data: {
     *     // ... data to create a Avaliacao
     *   }
     * })
     * 
     */
    create<T extends AvaliacaoCreateArgs>(args: SelectSubset<T, AvaliacaoCreateArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Avaliacaos.
     * @param {AvaliacaoCreateManyArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvaliacaoCreateManyArgs>(args?: SelectSubset<T, AvaliacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Avaliacaos and returns the data saved in the database.
     * @param {AvaliacaoCreateManyAndReturnArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Avaliacaos and only return the `id`
     * const avaliacaoWithIdOnly = await prisma.avaliacao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvaliacaoCreateManyAndReturnArgs>(args?: SelectSubset<T, AvaliacaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Avaliacao.
     * @param {AvaliacaoDeleteArgs} args - Arguments to delete one Avaliacao.
     * @example
     * // Delete one Avaliacao
     * const Avaliacao = await prisma.avaliacao.delete({
     *   where: {
     *     // ... filter to delete one Avaliacao
     *   }
     * })
     * 
     */
    delete<T extends AvaliacaoDeleteArgs>(args: SelectSubset<T, AvaliacaoDeleteArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Avaliacao.
     * @param {AvaliacaoUpdateArgs} args - Arguments to update one Avaliacao.
     * @example
     * // Update one Avaliacao
     * const avaliacao = await prisma.avaliacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvaliacaoUpdateArgs>(args: SelectSubset<T, AvaliacaoUpdateArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Avaliacaos.
     * @param {AvaliacaoDeleteManyArgs} args - Arguments to filter Avaliacaos to delete.
     * @example
     * // Delete a few Avaliacaos
     * const { count } = await prisma.avaliacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvaliacaoDeleteManyArgs>(args?: SelectSubset<T, AvaliacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avaliacaos
     * const avaliacao = await prisma.avaliacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvaliacaoUpdateManyArgs>(args: SelectSubset<T, AvaliacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Avaliacao.
     * @param {AvaliacaoUpsertArgs} args - Arguments to update or create a Avaliacao.
     * @example
     * // Update or create a Avaliacao
     * const avaliacao = await prisma.avaliacao.upsert({
     *   create: {
     *     // ... data to create a Avaliacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avaliacao we want to update
     *   }
     * })
     */
    upsert<T extends AvaliacaoUpsertArgs>(args: SelectSubset<T, AvaliacaoUpsertArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoCountArgs} args - Arguments to filter Avaliacaos to count.
     * @example
     * // Count the number of Avaliacaos
     * const count = await prisma.avaliacao.count({
     *   where: {
     *     // ... the filter for the Avaliacaos we want to count
     *   }
     * })
    **/
    count<T extends AvaliacaoCountArgs>(
      args?: Subset<T, AvaliacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvaliacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvaliacaoAggregateArgs>(args: Subset<T, AvaliacaoAggregateArgs>): Prisma.PrismaPromise<GetAvaliacaoAggregateType<T>>

    /**
     * Group by Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvaliacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvaliacaoGroupByArgs['orderBy'] }
        : { orderBy?: AvaliacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvaliacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvaliacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Avaliacao model
   */
  readonly fields: AvaliacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Avaliacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvaliacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aluno<T extends AlunoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlunoDefaultArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evento<T extends EventoAvaliacaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventoAvaliacaoDefaultArgs<ExtArgs>>): Prisma__EventoAvaliacaoClient<$Result.GetResult<Prisma.$EventoAvaliacaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    aplicador<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Avaliacao model
   */ 
  interface AvaliacaoFieldRefs {
    readonly id: FieldRef<"Avaliacao", 'Int'>
    readonly alunoId: FieldRef<"Avaliacao", 'Int'>
    readonly eventoId: FieldRef<"Avaliacao", 'Int'>
    readonly aplicadorId: FieldRef<"Avaliacao", 'Int'>
    readonly palavrasPorMinuto: FieldRef<"Avaliacao", 'Int'>
    readonly precisao: FieldRef<"Avaliacao", 'Float'>
    readonly fluencia: FieldRef<"Avaliacao", 'Float'>
    readonly compreensao: FieldRef<"Avaliacao", 'Float'>
    readonly nivelLeitura: FieldRef<"Avaliacao", 'String'>
    readonly observacoes: FieldRef<"Avaliacao", 'String'>
    readonly dataAvaliacao: FieldRef<"Avaliacao", 'DateTime'>
    readonly criadoEm: FieldRef<"Avaliacao", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Avaliacao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Avaliacao findUnique
   */
  export type AvaliacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao findUniqueOrThrow
   */
  export type AvaliacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao findFirst
   */
  export type AvaliacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao findFirstOrThrow
   */
  export type AvaliacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao findMany
   */
  export type AvaliacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacaos to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao create
   */
  export type AvaliacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Avaliacao.
     */
    data: XOR<AvaliacaoCreateInput, AvaliacaoUncheckedCreateInput>
  }

  /**
   * Avaliacao createMany
   */
  export type AvaliacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Avaliacaos.
     */
    data: AvaliacaoCreateManyInput | AvaliacaoCreateManyInput[]
  }

  /**
   * Avaliacao createManyAndReturn
   */
  export type AvaliacaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Avaliacaos.
     */
    data: AvaliacaoCreateManyInput | AvaliacaoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Avaliacao update
   */
  export type AvaliacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Avaliacao.
     */
    data: XOR<AvaliacaoUpdateInput, AvaliacaoUncheckedUpdateInput>
    /**
     * Choose, which Avaliacao to update.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao updateMany
   */
  export type AvaliacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Avaliacaos.
     */
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyInput>
    /**
     * Filter which Avaliacaos to update
     */
    where?: AvaliacaoWhereInput
  }

  /**
   * Avaliacao upsert
   */
  export type AvaliacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Avaliacao to update in case it exists.
     */
    where: AvaliacaoWhereUniqueInput
    /**
     * In case the Avaliacao found by the `where` argument doesn't exist, create a new Avaliacao with this data.
     */
    create: XOR<AvaliacaoCreateInput, AvaliacaoUncheckedCreateInput>
    /**
     * In case the Avaliacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvaliacaoUpdateInput, AvaliacaoUncheckedUpdateInput>
  }

  /**
   * Avaliacao delete
   */
  export type AvaliacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter which Avaliacao to delete.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao deleteMany
   */
  export type AvaliacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avaliacaos to delete
     */
    where?: AvaliacaoWhereInput
  }

  /**
   * Avaliacao without action
   */
  export type AvaliacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    tipo: 'tipo',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const RegiaoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type RegiaoScalarFieldEnum = (typeof RegiaoScalarFieldEnum)[keyof typeof RegiaoScalarFieldEnum]


  export const GrupoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type GrupoScalarFieldEnum = (typeof GrupoScalarFieldEnum)[keyof typeof GrupoScalarFieldEnum]


  export const EscolaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    regiaoId: 'regiaoId',
    grupoId: 'grupoId',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type EscolaScalarFieldEnum = (typeof EscolaScalarFieldEnum)[keyof typeof EscolaScalarFieldEnum]


  export const EscolaUsuarioScalarFieldEnum: {
    id: 'id',
    escolaId: 'escolaId',
    usuarioId: 'usuarioId',
    criadoEm: 'criadoEm'
  };

  export type EscolaUsuarioScalarFieldEnum = (typeof EscolaUsuarioScalarFieldEnum)[keyof typeof EscolaUsuarioScalarFieldEnum]


  export const AnoEscolarScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type AnoEscolarScalarFieldEnum = (typeof AnoEscolarScalarFieldEnum)[keyof typeof AnoEscolarScalarFieldEnum]


  export const TurmaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    escolaId: 'escolaId',
    anoEscolarId: 'anoEscolarId',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type TurmaScalarFieldEnum = (typeof TurmaScalarFieldEnum)[keyof typeof TurmaScalarFieldEnum]


  export const AlunoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    dataNascimento: 'dataNascimento',
    turmaId: 'turmaId',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type AlunoScalarFieldEnum = (typeof AlunoScalarFieldEnum)[keyof typeof AlunoScalarFieldEnum]


  export const EventoAvaliacaoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    dataInicio: 'dataInicio',
    dataFim: 'dataFim',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type EventoAvaliacaoScalarFieldEnum = (typeof EventoAvaliacaoScalarFieldEnum)[keyof typeof EventoAvaliacaoScalarFieldEnum]


  export const AvaliacaoScalarFieldEnum: {
    id: 'id',
    alunoId: 'alunoId',
    eventoId: 'eventoId',
    aplicadorId: 'aplicadorId',
    palavrasPorMinuto: 'palavrasPorMinuto',
    precisao: 'precisao',
    fluencia: 'fluencia',
    compreensao: 'compreensao',
    nivelLeitura: 'nivelLeitura',
    observacoes: 'observacoes',
    dataAvaliacao: 'dataAvaliacao',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type AvaliacaoScalarFieldEnum = (typeof AvaliacaoScalarFieldEnum)[keyof typeof AvaliacaoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nome?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    tipo?: StringFilter<"Usuario"> | string
    ativo?: BoolFilter<"Usuario"> | boolean
    criadoEm?: DateTimeFilter<"Usuario"> | Date | string
    atualizadoEm?: DateTimeFilter<"Usuario"> | Date | string
    escolas?: EscolaUsuarioListRelationFilter
    avaliacoesAplicadas?: AvaliacaoListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    escolas?: EscolaUsuarioOrderByRelationAggregateInput
    avaliacoesAplicadas?: AvaliacaoOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nome?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    tipo?: StringFilter<"Usuario"> | string
    ativo?: BoolFilter<"Usuario"> | boolean
    criadoEm?: DateTimeFilter<"Usuario"> | Date | string
    atualizadoEm?: DateTimeFilter<"Usuario"> | Date | string
    escolas?: EscolaUsuarioListRelationFilter
    avaliacoesAplicadas?: AvaliacaoListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nome?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
    tipo?: StringWithAggregatesFilter<"Usuario"> | string
    ativo?: BoolWithAggregatesFilter<"Usuario"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type RegiaoWhereInput = {
    AND?: RegiaoWhereInput | RegiaoWhereInput[]
    OR?: RegiaoWhereInput[]
    NOT?: RegiaoWhereInput | RegiaoWhereInput[]
    id?: IntFilter<"Regiao"> | number
    nome?: StringFilter<"Regiao"> | string
    criadoEm?: DateTimeFilter<"Regiao"> | Date | string
    atualizadoEm?: DateTimeFilter<"Regiao"> | Date | string
    escolas?: EscolaListRelationFilter
  }

  export type RegiaoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    escolas?: EscolaOrderByRelationAggregateInput
  }

  export type RegiaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegiaoWhereInput | RegiaoWhereInput[]
    OR?: RegiaoWhereInput[]
    NOT?: RegiaoWhereInput | RegiaoWhereInput[]
    nome?: StringFilter<"Regiao"> | string
    criadoEm?: DateTimeFilter<"Regiao"> | Date | string
    atualizadoEm?: DateTimeFilter<"Regiao"> | Date | string
    escolas?: EscolaListRelationFilter
  }, "id">

  export type RegiaoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: RegiaoCountOrderByAggregateInput
    _avg?: RegiaoAvgOrderByAggregateInput
    _max?: RegiaoMaxOrderByAggregateInput
    _min?: RegiaoMinOrderByAggregateInput
    _sum?: RegiaoSumOrderByAggregateInput
  }

  export type RegiaoScalarWhereWithAggregatesInput = {
    AND?: RegiaoScalarWhereWithAggregatesInput | RegiaoScalarWhereWithAggregatesInput[]
    OR?: RegiaoScalarWhereWithAggregatesInput[]
    NOT?: RegiaoScalarWhereWithAggregatesInput | RegiaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Regiao"> | number
    nome?: StringWithAggregatesFilter<"Regiao"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"Regiao"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Regiao"> | Date | string
  }

  export type GrupoWhereInput = {
    AND?: GrupoWhereInput | GrupoWhereInput[]
    OR?: GrupoWhereInput[]
    NOT?: GrupoWhereInput | GrupoWhereInput[]
    id?: IntFilter<"Grupo"> | number
    nome?: StringFilter<"Grupo"> | string
    criadoEm?: DateTimeFilter<"Grupo"> | Date | string
    atualizadoEm?: DateTimeFilter<"Grupo"> | Date | string
    escolas?: EscolaListRelationFilter
  }

  export type GrupoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    escolas?: EscolaOrderByRelationAggregateInput
  }

  export type GrupoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GrupoWhereInput | GrupoWhereInput[]
    OR?: GrupoWhereInput[]
    NOT?: GrupoWhereInput | GrupoWhereInput[]
    nome?: StringFilter<"Grupo"> | string
    criadoEm?: DateTimeFilter<"Grupo"> | Date | string
    atualizadoEm?: DateTimeFilter<"Grupo"> | Date | string
    escolas?: EscolaListRelationFilter
  }, "id">

  export type GrupoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: GrupoCountOrderByAggregateInput
    _avg?: GrupoAvgOrderByAggregateInput
    _max?: GrupoMaxOrderByAggregateInput
    _min?: GrupoMinOrderByAggregateInput
    _sum?: GrupoSumOrderByAggregateInput
  }

  export type GrupoScalarWhereWithAggregatesInput = {
    AND?: GrupoScalarWhereWithAggregatesInput | GrupoScalarWhereWithAggregatesInput[]
    OR?: GrupoScalarWhereWithAggregatesInput[]
    NOT?: GrupoScalarWhereWithAggregatesInput | GrupoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Grupo"> | number
    nome?: StringWithAggregatesFilter<"Grupo"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"Grupo"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Grupo"> | Date | string
  }

  export type EscolaWhereInput = {
    AND?: EscolaWhereInput | EscolaWhereInput[]
    OR?: EscolaWhereInput[]
    NOT?: EscolaWhereInput | EscolaWhereInput[]
    id?: IntFilter<"Escola"> | number
    nome?: StringFilter<"Escola"> | string
    regiaoId?: IntFilter<"Escola"> | number
    grupoId?: IntNullableFilter<"Escola"> | number | null
    criadoEm?: DateTimeFilter<"Escola"> | Date | string
    atualizadoEm?: DateTimeFilter<"Escola"> | Date | string
    regiao?: XOR<RegiaoRelationFilter, RegiaoWhereInput>
    grupo?: XOR<GrupoNullableRelationFilter, GrupoWhereInput> | null
    turmas?: TurmaListRelationFilter
    usuarios?: EscolaUsuarioListRelationFilter
  }

  export type EscolaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    regiaoId?: SortOrder
    grupoId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    regiao?: RegiaoOrderByWithRelationInput
    grupo?: GrupoOrderByWithRelationInput
    turmas?: TurmaOrderByRelationAggregateInput
    usuarios?: EscolaUsuarioOrderByRelationAggregateInput
  }

  export type EscolaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EscolaWhereInput | EscolaWhereInput[]
    OR?: EscolaWhereInput[]
    NOT?: EscolaWhereInput | EscolaWhereInput[]
    nome?: StringFilter<"Escola"> | string
    regiaoId?: IntFilter<"Escola"> | number
    grupoId?: IntNullableFilter<"Escola"> | number | null
    criadoEm?: DateTimeFilter<"Escola"> | Date | string
    atualizadoEm?: DateTimeFilter<"Escola"> | Date | string
    regiao?: XOR<RegiaoRelationFilter, RegiaoWhereInput>
    grupo?: XOR<GrupoNullableRelationFilter, GrupoWhereInput> | null
    turmas?: TurmaListRelationFilter
    usuarios?: EscolaUsuarioListRelationFilter
  }, "id">

  export type EscolaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    regiaoId?: SortOrder
    grupoId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: EscolaCountOrderByAggregateInput
    _avg?: EscolaAvgOrderByAggregateInput
    _max?: EscolaMaxOrderByAggregateInput
    _min?: EscolaMinOrderByAggregateInput
    _sum?: EscolaSumOrderByAggregateInput
  }

  export type EscolaScalarWhereWithAggregatesInput = {
    AND?: EscolaScalarWhereWithAggregatesInput | EscolaScalarWhereWithAggregatesInput[]
    OR?: EscolaScalarWhereWithAggregatesInput[]
    NOT?: EscolaScalarWhereWithAggregatesInput | EscolaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Escola"> | number
    nome?: StringWithAggregatesFilter<"Escola"> | string
    regiaoId?: IntWithAggregatesFilter<"Escola"> | number
    grupoId?: IntNullableWithAggregatesFilter<"Escola"> | number | null
    criadoEm?: DateTimeWithAggregatesFilter<"Escola"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Escola"> | Date | string
  }

  export type EscolaUsuarioWhereInput = {
    AND?: EscolaUsuarioWhereInput | EscolaUsuarioWhereInput[]
    OR?: EscolaUsuarioWhereInput[]
    NOT?: EscolaUsuarioWhereInput | EscolaUsuarioWhereInput[]
    id?: IntFilter<"EscolaUsuario"> | number
    escolaId?: IntFilter<"EscolaUsuario"> | number
    usuarioId?: IntFilter<"EscolaUsuario"> | number
    criadoEm?: DateTimeFilter<"EscolaUsuario"> | Date | string
    escola?: XOR<EscolaRelationFilter, EscolaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type EscolaUsuarioOrderByWithRelationInput = {
    id?: SortOrder
    escolaId?: SortOrder
    usuarioId?: SortOrder
    criadoEm?: SortOrder
    escola?: EscolaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type EscolaUsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    escolaId_usuarioId?: EscolaUsuarioEscolaIdUsuarioIdCompoundUniqueInput
    AND?: EscolaUsuarioWhereInput | EscolaUsuarioWhereInput[]
    OR?: EscolaUsuarioWhereInput[]
    NOT?: EscolaUsuarioWhereInput | EscolaUsuarioWhereInput[]
    escolaId?: IntFilter<"EscolaUsuario"> | number
    usuarioId?: IntFilter<"EscolaUsuario"> | number
    criadoEm?: DateTimeFilter<"EscolaUsuario"> | Date | string
    escola?: XOR<EscolaRelationFilter, EscolaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "escolaId_usuarioId">

  export type EscolaUsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    escolaId?: SortOrder
    usuarioId?: SortOrder
    criadoEm?: SortOrder
    _count?: EscolaUsuarioCountOrderByAggregateInput
    _avg?: EscolaUsuarioAvgOrderByAggregateInput
    _max?: EscolaUsuarioMaxOrderByAggregateInput
    _min?: EscolaUsuarioMinOrderByAggregateInput
    _sum?: EscolaUsuarioSumOrderByAggregateInput
  }

  export type EscolaUsuarioScalarWhereWithAggregatesInput = {
    AND?: EscolaUsuarioScalarWhereWithAggregatesInput | EscolaUsuarioScalarWhereWithAggregatesInput[]
    OR?: EscolaUsuarioScalarWhereWithAggregatesInput[]
    NOT?: EscolaUsuarioScalarWhereWithAggregatesInput | EscolaUsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EscolaUsuario"> | number
    escolaId?: IntWithAggregatesFilter<"EscolaUsuario"> | number
    usuarioId?: IntWithAggregatesFilter<"EscolaUsuario"> | number
    criadoEm?: DateTimeWithAggregatesFilter<"EscolaUsuario"> | Date | string
  }

  export type AnoEscolarWhereInput = {
    AND?: AnoEscolarWhereInput | AnoEscolarWhereInput[]
    OR?: AnoEscolarWhereInput[]
    NOT?: AnoEscolarWhereInput | AnoEscolarWhereInput[]
    id?: IntFilter<"AnoEscolar"> | number
    nome?: StringFilter<"AnoEscolar"> | string
    criadoEm?: DateTimeFilter<"AnoEscolar"> | Date | string
    atualizadoEm?: DateTimeFilter<"AnoEscolar"> | Date | string
    turmas?: TurmaListRelationFilter
  }

  export type AnoEscolarOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    turmas?: TurmaOrderByRelationAggregateInput
  }

  export type AnoEscolarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnoEscolarWhereInput | AnoEscolarWhereInput[]
    OR?: AnoEscolarWhereInput[]
    NOT?: AnoEscolarWhereInput | AnoEscolarWhereInput[]
    nome?: StringFilter<"AnoEscolar"> | string
    criadoEm?: DateTimeFilter<"AnoEscolar"> | Date | string
    atualizadoEm?: DateTimeFilter<"AnoEscolar"> | Date | string
    turmas?: TurmaListRelationFilter
  }, "id">

  export type AnoEscolarOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: AnoEscolarCountOrderByAggregateInput
    _avg?: AnoEscolarAvgOrderByAggregateInput
    _max?: AnoEscolarMaxOrderByAggregateInput
    _min?: AnoEscolarMinOrderByAggregateInput
    _sum?: AnoEscolarSumOrderByAggregateInput
  }

  export type AnoEscolarScalarWhereWithAggregatesInput = {
    AND?: AnoEscolarScalarWhereWithAggregatesInput | AnoEscolarScalarWhereWithAggregatesInput[]
    OR?: AnoEscolarScalarWhereWithAggregatesInput[]
    NOT?: AnoEscolarScalarWhereWithAggregatesInput | AnoEscolarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AnoEscolar"> | number
    nome?: StringWithAggregatesFilter<"AnoEscolar"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"AnoEscolar"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"AnoEscolar"> | Date | string
  }

  export type TurmaWhereInput = {
    AND?: TurmaWhereInput | TurmaWhereInput[]
    OR?: TurmaWhereInput[]
    NOT?: TurmaWhereInput | TurmaWhereInput[]
    id?: IntFilter<"Turma"> | number
    nome?: StringFilter<"Turma"> | string
    escolaId?: IntFilter<"Turma"> | number
    anoEscolarId?: IntFilter<"Turma"> | number
    criadoEm?: DateTimeFilter<"Turma"> | Date | string
    atualizadoEm?: DateTimeFilter<"Turma"> | Date | string
    escola?: XOR<EscolaRelationFilter, EscolaWhereInput>
    anoEscolar?: XOR<AnoEscolarRelationFilter, AnoEscolarWhereInput>
    alunos?: AlunoListRelationFilter
  }

  export type TurmaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    escolaId?: SortOrder
    anoEscolarId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    escola?: EscolaOrderByWithRelationInput
    anoEscolar?: AnoEscolarOrderByWithRelationInput
    alunos?: AlunoOrderByRelationAggregateInput
  }

  export type TurmaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TurmaWhereInput | TurmaWhereInput[]
    OR?: TurmaWhereInput[]
    NOT?: TurmaWhereInput | TurmaWhereInput[]
    nome?: StringFilter<"Turma"> | string
    escolaId?: IntFilter<"Turma"> | number
    anoEscolarId?: IntFilter<"Turma"> | number
    criadoEm?: DateTimeFilter<"Turma"> | Date | string
    atualizadoEm?: DateTimeFilter<"Turma"> | Date | string
    escola?: XOR<EscolaRelationFilter, EscolaWhereInput>
    anoEscolar?: XOR<AnoEscolarRelationFilter, AnoEscolarWhereInput>
    alunos?: AlunoListRelationFilter
  }, "id">

  export type TurmaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    escolaId?: SortOrder
    anoEscolarId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: TurmaCountOrderByAggregateInput
    _avg?: TurmaAvgOrderByAggregateInput
    _max?: TurmaMaxOrderByAggregateInput
    _min?: TurmaMinOrderByAggregateInput
    _sum?: TurmaSumOrderByAggregateInput
  }

  export type TurmaScalarWhereWithAggregatesInput = {
    AND?: TurmaScalarWhereWithAggregatesInput | TurmaScalarWhereWithAggregatesInput[]
    OR?: TurmaScalarWhereWithAggregatesInput[]
    NOT?: TurmaScalarWhereWithAggregatesInput | TurmaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Turma"> | number
    nome?: StringWithAggregatesFilter<"Turma"> | string
    escolaId?: IntWithAggregatesFilter<"Turma"> | number
    anoEscolarId?: IntWithAggregatesFilter<"Turma"> | number
    criadoEm?: DateTimeWithAggregatesFilter<"Turma"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Turma"> | Date | string
  }

  export type AlunoWhereInput = {
    AND?: AlunoWhereInput | AlunoWhereInput[]
    OR?: AlunoWhereInput[]
    NOT?: AlunoWhereInput | AlunoWhereInput[]
    id?: IntFilter<"Aluno"> | number
    nome?: StringFilter<"Aluno"> | string
    dataNascimento?: DateTimeNullableFilter<"Aluno"> | Date | string | null
    turmaId?: IntFilter<"Aluno"> | number
    criadoEm?: DateTimeFilter<"Aluno"> | Date | string
    atualizadoEm?: DateTimeFilter<"Aluno"> | Date | string
    turma?: XOR<TurmaRelationFilter, TurmaWhereInput>
    avaliacoes?: AvaliacaoListRelationFilter
  }

  export type AlunoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    dataNascimento?: SortOrderInput | SortOrder
    turmaId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    turma?: TurmaOrderByWithRelationInput
    avaliacoes?: AvaliacaoOrderByRelationAggregateInput
  }

  export type AlunoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AlunoWhereInput | AlunoWhereInput[]
    OR?: AlunoWhereInput[]
    NOT?: AlunoWhereInput | AlunoWhereInput[]
    nome?: StringFilter<"Aluno"> | string
    dataNascimento?: DateTimeNullableFilter<"Aluno"> | Date | string | null
    turmaId?: IntFilter<"Aluno"> | number
    criadoEm?: DateTimeFilter<"Aluno"> | Date | string
    atualizadoEm?: DateTimeFilter<"Aluno"> | Date | string
    turma?: XOR<TurmaRelationFilter, TurmaWhereInput>
    avaliacoes?: AvaliacaoListRelationFilter
  }, "id">

  export type AlunoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    dataNascimento?: SortOrderInput | SortOrder
    turmaId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: AlunoCountOrderByAggregateInput
    _avg?: AlunoAvgOrderByAggregateInput
    _max?: AlunoMaxOrderByAggregateInput
    _min?: AlunoMinOrderByAggregateInput
    _sum?: AlunoSumOrderByAggregateInput
  }

  export type AlunoScalarWhereWithAggregatesInput = {
    AND?: AlunoScalarWhereWithAggregatesInput | AlunoScalarWhereWithAggregatesInput[]
    OR?: AlunoScalarWhereWithAggregatesInput[]
    NOT?: AlunoScalarWhereWithAggregatesInput | AlunoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Aluno"> | number
    nome?: StringWithAggregatesFilter<"Aluno"> | string
    dataNascimento?: DateTimeNullableWithAggregatesFilter<"Aluno"> | Date | string | null
    turmaId?: IntWithAggregatesFilter<"Aluno"> | number
    criadoEm?: DateTimeWithAggregatesFilter<"Aluno"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Aluno"> | Date | string
  }

  export type EventoAvaliacaoWhereInput = {
    AND?: EventoAvaliacaoWhereInput | EventoAvaliacaoWhereInput[]
    OR?: EventoAvaliacaoWhereInput[]
    NOT?: EventoAvaliacaoWhereInput | EventoAvaliacaoWhereInput[]
    id?: IntFilter<"EventoAvaliacao"> | number
    nome?: StringFilter<"EventoAvaliacao"> | string
    dataInicio?: DateTimeFilter<"EventoAvaliacao"> | Date | string
    dataFim?: DateTimeFilter<"EventoAvaliacao"> | Date | string
    ativo?: BoolFilter<"EventoAvaliacao"> | boolean
    criadoEm?: DateTimeFilter<"EventoAvaliacao"> | Date | string
    atualizadoEm?: DateTimeFilter<"EventoAvaliacao"> | Date | string
    avaliacoes?: AvaliacaoListRelationFilter
  }

  export type EventoAvaliacaoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    dataInicio?: SortOrder
    dataFim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    avaliacoes?: AvaliacaoOrderByRelationAggregateInput
  }

  export type EventoAvaliacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventoAvaliacaoWhereInput | EventoAvaliacaoWhereInput[]
    OR?: EventoAvaliacaoWhereInput[]
    NOT?: EventoAvaliacaoWhereInput | EventoAvaliacaoWhereInput[]
    nome?: StringFilter<"EventoAvaliacao"> | string
    dataInicio?: DateTimeFilter<"EventoAvaliacao"> | Date | string
    dataFim?: DateTimeFilter<"EventoAvaliacao"> | Date | string
    ativo?: BoolFilter<"EventoAvaliacao"> | boolean
    criadoEm?: DateTimeFilter<"EventoAvaliacao"> | Date | string
    atualizadoEm?: DateTimeFilter<"EventoAvaliacao"> | Date | string
    avaliacoes?: AvaliacaoListRelationFilter
  }, "id">

  export type EventoAvaliacaoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    dataInicio?: SortOrder
    dataFim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: EventoAvaliacaoCountOrderByAggregateInput
    _avg?: EventoAvaliacaoAvgOrderByAggregateInput
    _max?: EventoAvaliacaoMaxOrderByAggregateInput
    _min?: EventoAvaliacaoMinOrderByAggregateInput
    _sum?: EventoAvaliacaoSumOrderByAggregateInput
  }

  export type EventoAvaliacaoScalarWhereWithAggregatesInput = {
    AND?: EventoAvaliacaoScalarWhereWithAggregatesInput | EventoAvaliacaoScalarWhereWithAggregatesInput[]
    OR?: EventoAvaliacaoScalarWhereWithAggregatesInput[]
    NOT?: EventoAvaliacaoScalarWhereWithAggregatesInput | EventoAvaliacaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EventoAvaliacao"> | number
    nome?: StringWithAggregatesFilter<"EventoAvaliacao"> | string
    dataInicio?: DateTimeWithAggregatesFilter<"EventoAvaliacao"> | Date | string
    dataFim?: DateTimeWithAggregatesFilter<"EventoAvaliacao"> | Date | string
    ativo?: BoolWithAggregatesFilter<"EventoAvaliacao"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"EventoAvaliacao"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"EventoAvaliacao"> | Date | string
  }

  export type AvaliacaoWhereInput = {
    AND?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    OR?: AvaliacaoWhereInput[]
    NOT?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    id?: IntFilter<"Avaliacao"> | number
    alunoId?: IntFilter<"Avaliacao"> | number
    eventoId?: IntFilter<"Avaliacao"> | number
    aplicadorId?: IntFilter<"Avaliacao"> | number
    palavrasPorMinuto?: IntFilter<"Avaliacao"> | number
    precisao?: FloatFilter<"Avaliacao"> | number
    fluencia?: FloatFilter<"Avaliacao"> | number
    compreensao?: FloatFilter<"Avaliacao"> | number
    nivelLeitura?: StringFilter<"Avaliacao"> | string
    observacoes?: StringNullableFilter<"Avaliacao"> | string | null
    dataAvaliacao?: DateTimeFilter<"Avaliacao"> | Date | string
    criadoEm?: DateTimeFilter<"Avaliacao"> | Date | string
    atualizadoEm?: DateTimeFilter<"Avaliacao"> | Date | string
    aluno?: XOR<AlunoRelationFilter, AlunoWhereInput>
    evento?: XOR<EventoAvaliacaoRelationFilter, EventoAvaliacaoWhereInput>
    aplicador?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type AvaliacaoOrderByWithRelationInput = {
    id?: SortOrder
    alunoId?: SortOrder
    eventoId?: SortOrder
    aplicadorId?: SortOrder
    palavrasPorMinuto?: SortOrder
    precisao?: SortOrder
    fluencia?: SortOrder
    compreensao?: SortOrder
    nivelLeitura?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    dataAvaliacao?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    aluno?: AlunoOrderByWithRelationInput
    evento?: EventoAvaliacaoOrderByWithRelationInput
    aplicador?: UsuarioOrderByWithRelationInput
  }

  export type AvaliacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    OR?: AvaliacaoWhereInput[]
    NOT?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    alunoId?: IntFilter<"Avaliacao"> | number
    eventoId?: IntFilter<"Avaliacao"> | number
    aplicadorId?: IntFilter<"Avaliacao"> | number
    palavrasPorMinuto?: IntFilter<"Avaliacao"> | number
    precisao?: FloatFilter<"Avaliacao"> | number
    fluencia?: FloatFilter<"Avaliacao"> | number
    compreensao?: FloatFilter<"Avaliacao"> | number
    nivelLeitura?: StringFilter<"Avaliacao"> | string
    observacoes?: StringNullableFilter<"Avaliacao"> | string | null
    dataAvaliacao?: DateTimeFilter<"Avaliacao"> | Date | string
    criadoEm?: DateTimeFilter<"Avaliacao"> | Date | string
    atualizadoEm?: DateTimeFilter<"Avaliacao"> | Date | string
    aluno?: XOR<AlunoRelationFilter, AlunoWhereInput>
    evento?: XOR<EventoAvaliacaoRelationFilter, EventoAvaliacaoWhereInput>
    aplicador?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type AvaliacaoOrderByWithAggregationInput = {
    id?: SortOrder
    alunoId?: SortOrder
    eventoId?: SortOrder
    aplicadorId?: SortOrder
    palavrasPorMinuto?: SortOrder
    precisao?: SortOrder
    fluencia?: SortOrder
    compreensao?: SortOrder
    nivelLeitura?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    dataAvaliacao?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: AvaliacaoCountOrderByAggregateInput
    _avg?: AvaliacaoAvgOrderByAggregateInput
    _max?: AvaliacaoMaxOrderByAggregateInput
    _min?: AvaliacaoMinOrderByAggregateInput
    _sum?: AvaliacaoSumOrderByAggregateInput
  }

  export type AvaliacaoScalarWhereWithAggregatesInput = {
    AND?: AvaliacaoScalarWhereWithAggregatesInput | AvaliacaoScalarWhereWithAggregatesInput[]
    OR?: AvaliacaoScalarWhereWithAggregatesInput[]
    NOT?: AvaliacaoScalarWhereWithAggregatesInput | AvaliacaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Avaliacao"> | number
    alunoId?: IntWithAggregatesFilter<"Avaliacao"> | number
    eventoId?: IntWithAggregatesFilter<"Avaliacao"> | number
    aplicadorId?: IntWithAggregatesFilter<"Avaliacao"> | number
    palavrasPorMinuto?: IntWithAggregatesFilter<"Avaliacao"> | number
    precisao?: FloatWithAggregatesFilter<"Avaliacao"> | number
    fluencia?: FloatWithAggregatesFilter<"Avaliacao"> | number
    compreensao?: FloatWithAggregatesFilter<"Avaliacao"> | number
    nivelLeitura?: StringWithAggregatesFilter<"Avaliacao"> | string
    observacoes?: StringNullableWithAggregatesFilter<"Avaliacao"> | string | null
    dataAvaliacao?: DateTimeWithAggregatesFilter<"Avaliacao"> | Date | string
    criadoEm?: DateTimeWithAggregatesFilter<"Avaliacao"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Avaliacao"> | Date | string
  }

  export type UsuarioCreateInput = {
    nome: string
    email: string
    senha: string
    tipo: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escolas?: EscolaUsuarioCreateNestedManyWithoutUsuarioInput
    avaliacoesAplicadas?: AvaliacaoCreateNestedManyWithoutAplicadorInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nome: string
    email: string
    senha: string
    tipo: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escolas?: EscolaUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    avaliacoesAplicadas?: AvaliacaoUncheckedCreateNestedManyWithoutAplicadorInput
  }

  export type UsuarioUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escolas?: EscolaUsuarioUpdateManyWithoutUsuarioNestedInput
    avaliacoesAplicadas?: AvaliacaoUpdateManyWithoutAplicadorNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escolas?: EscolaUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    avaliacoesAplicadas?: AvaliacaoUncheckedUpdateManyWithoutAplicadorNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nome: string
    email: string
    senha: string
    tipo: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegiaoCreateInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escolas?: EscolaCreateNestedManyWithoutRegiaoInput
  }

  export type RegiaoUncheckedCreateInput = {
    id?: number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escolas?: EscolaUncheckedCreateNestedManyWithoutRegiaoInput
  }

  export type RegiaoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escolas?: EscolaUpdateManyWithoutRegiaoNestedInput
  }

  export type RegiaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escolas?: EscolaUncheckedUpdateManyWithoutRegiaoNestedInput
  }

  export type RegiaoCreateManyInput = {
    id?: number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type RegiaoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegiaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrupoCreateInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escolas?: EscolaCreateNestedManyWithoutGrupoInput
  }

  export type GrupoUncheckedCreateInput = {
    id?: number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escolas?: EscolaUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type GrupoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escolas?: EscolaUpdateManyWithoutGrupoNestedInput
  }

  export type GrupoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escolas?: EscolaUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type GrupoCreateManyInput = {
    id?: number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type GrupoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrupoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaCreateInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    regiao: RegiaoCreateNestedOneWithoutEscolasInput
    grupo?: GrupoCreateNestedOneWithoutEscolasInput
    turmas?: TurmaCreateNestedManyWithoutEscolaInput
    usuarios?: EscolaUsuarioCreateNestedManyWithoutEscolaInput
  }

  export type EscolaUncheckedCreateInput = {
    id?: number
    nome: string
    regiaoId: number
    grupoId?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    turmas?: TurmaUncheckedCreateNestedManyWithoutEscolaInput
    usuarios?: EscolaUsuarioUncheckedCreateNestedManyWithoutEscolaInput
  }

  export type EscolaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    regiao?: RegiaoUpdateOneRequiredWithoutEscolasNestedInput
    grupo?: GrupoUpdateOneWithoutEscolasNestedInput
    turmas?: TurmaUpdateManyWithoutEscolaNestedInput
    usuarios?: EscolaUsuarioUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiaoId?: IntFieldUpdateOperationsInput | number
    grupoId?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    turmas?: TurmaUncheckedUpdateManyWithoutEscolaNestedInput
    usuarios?: EscolaUsuarioUncheckedUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaCreateManyInput = {
    id?: number
    nome: string
    regiaoId: number
    grupoId?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type EscolaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiaoId?: IntFieldUpdateOperationsInput | number
    grupoId?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaUsuarioCreateInput = {
    criadoEm?: Date | string
    escola: EscolaCreateNestedOneWithoutUsuariosInput
    usuario: UsuarioCreateNestedOneWithoutEscolasInput
  }

  export type EscolaUsuarioUncheckedCreateInput = {
    id?: number
    escolaId: number
    usuarioId: number
    criadoEm?: Date | string
  }

  export type EscolaUsuarioUpdateInput = {
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escola?: EscolaUpdateOneRequiredWithoutUsuariosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEscolasNestedInput
  }

  export type EscolaUsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    escolaId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaUsuarioCreateManyInput = {
    id?: number
    escolaId: number
    usuarioId: number
    criadoEm?: Date | string
  }

  export type EscolaUsuarioUpdateManyMutationInput = {
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaUsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    escolaId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnoEscolarCreateInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    turmas?: TurmaCreateNestedManyWithoutAnoEscolarInput
  }

  export type AnoEscolarUncheckedCreateInput = {
    id?: number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    turmas?: TurmaUncheckedCreateNestedManyWithoutAnoEscolarInput
  }

  export type AnoEscolarUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    turmas?: TurmaUpdateManyWithoutAnoEscolarNestedInput
  }

  export type AnoEscolarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    turmas?: TurmaUncheckedUpdateManyWithoutAnoEscolarNestedInput
  }

  export type AnoEscolarCreateManyInput = {
    id?: number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AnoEscolarUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnoEscolarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TurmaCreateInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escola: EscolaCreateNestedOneWithoutTurmasInput
    anoEscolar: AnoEscolarCreateNestedOneWithoutTurmasInput
    alunos?: AlunoCreateNestedManyWithoutTurmaInput
  }

  export type TurmaUncheckedCreateInput = {
    id?: number
    nome: string
    escolaId: number
    anoEscolarId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    alunos?: AlunoUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type TurmaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escola?: EscolaUpdateOneRequiredWithoutTurmasNestedInput
    anoEscolar?: AnoEscolarUpdateOneRequiredWithoutTurmasNestedInput
    alunos?: AlunoUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    escolaId?: IntFieldUpdateOperationsInput | number
    anoEscolarId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    alunos?: AlunoUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaCreateManyInput = {
    id?: number
    nome: string
    escolaId: number
    anoEscolarId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TurmaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TurmaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    escolaId?: IntFieldUpdateOperationsInput | number
    anoEscolarId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlunoCreateInput = {
    nome: string
    dataNascimento?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    turma: TurmaCreateNestedOneWithoutAlunosInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutAlunoInput
  }

  export type AlunoUncheckedCreateInput = {
    id?: number
    nome: string
    dataNascimento?: Date | string | null
    turmaId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type AlunoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    turma?: TurmaUpdateOneRequiredWithoutAlunosNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutAlunoNestedInput
  }

  export type AlunoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turmaId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type AlunoCreateManyInput = {
    id?: number
    nome: string
    dataNascimento?: Date | string | null
    turmaId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AlunoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlunoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turmaId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoAvaliacaoCreateInput = {
    nome: string
    dataInicio: Date | string
    dataFim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    avaliacoes?: AvaliacaoCreateNestedManyWithoutEventoInput
  }

  export type EventoAvaliacaoUncheckedCreateInput = {
    id?: number
    nome: string
    dataInicio: Date | string
    dataFim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutEventoInput
  }

  export type EventoAvaliacaoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliacoes?: AvaliacaoUpdateManyWithoutEventoNestedInput
  }

  export type EventoAvaliacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutEventoNestedInput
  }

  export type EventoAvaliacaoCreateManyInput = {
    id?: number
    nome: string
    dataInicio: Date | string
    dataFim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type EventoAvaliacaoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoAvaliacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoCreateInput = {
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    aluno: AlunoCreateNestedOneWithoutAvaliacoesInput
    evento: EventoAvaliacaoCreateNestedOneWithoutAvaliacoesInput
    aplicador: UsuarioCreateNestedOneWithoutAvaliacoesAplicadasInput
  }

  export type AvaliacaoUncheckedCreateInput = {
    id?: number
    alunoId: number
    eventoId: number
    aplicadorId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AvaliacaoUpdateInput = {
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    aluno?: AlunoUpdateOneRequiredWithoutAvaliacoesNestedInput
    evento?: EventoAvaliacaoUpdateOneRequiredWithoutAvaliacoesNestedInput
    aplicador?: UsuarioUpdateOneRequiredWithoutAvaliacoesAplicadasNestedInput
  }

  export type AvaliacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alunoId?: IntFieldUpdateOperationsInput | number
    eventoId?: IntFieldUpdateOperationsInput | number
    aplicadorId?: IntFieldUpdateOperationsInput | number
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoCreateManyInput = {
    id?: number
    alunoId: number
    eventoId: number
    aplicadorId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AvaliacaoUpdateManyMutationInput = {
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alunoId?: IntFieldUpdateOperationsInput | number
    eventoId?: IntFieldUpdateOperationsInput | number
    aplicadorId?: IntFieldUpdateOperationsInput | number
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EscolaUsuarioListRelationFilter = {
    every?: EscolaUsuarioWhereInput
    some?: EscolaUsuarioWhereInput
    none?: EscolaUsuarioWhereInput
  }

  export type AvaliacaoListRelationFilter = {
    every?: AvaliacaoWhereInput
    some?: AvaliacaoWhereInput
    none?: AvaliacaoWhereInput
  }

  export type EscolaUsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AvaliacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EscolaListRelationFilter = {
    every?: EscolaWhereInput
    some?: EscolaWhereInput
    none?: EscolaWhereInput
  }

  export type EscolaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegiaoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type RegiaoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegiaoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type RegiaoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type RegiaoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GrupoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type GrupoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GrupoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type GrupoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type GrupoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RegiaoRelationFilter = {
    is?: RegiaoWhereInput
    isNot?: RegiaoWhereInput
  }

  export type GrupoNullableRelationFilter = {
    is?: GrupoWhereInput | null
    isNot?: GrupoWhereInput | null
  }

  export type TurmaListRelationFilter = {
    every?: TurmaWhereInput
    some?: TurmaWhereInput
    none?: TurmaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TurmaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EscolaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    regiaoId?: SortOrder
    grupoId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type EscolaAvgOrderByAggregateInput = {
    id?: SortOrder
    regiaoId?: SortOrder
    grupoId?: SortOrder
  }

  export type EscolaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    regiaoId?: SortOrder
    grupoId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type EscolaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    regiaoId?: SortOrder
    grupoId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type EscolaSumOrderByAggregateInput = {
    id?: SortOrder
    regiaoId?: SortOrder
    grupoId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EscolaRelationFilter = {
    is?: EscolaWhereInput
    isNot?: EscolaWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type EscolaUsuarioEscolaIdUsuarioIdCompoundUniqueInput = {
    escolaId: number
    usuarioId: number
  }

  export type EscolaUsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    escolaId?: SortOrder
    usuarioId?: SortOrder
    criadoEm?: SortOrder
  }

  export type EscolaUsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    escolaId?: SortOrder
    usuarioId?: SortOrder
  }

  export type EscolaUsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    escolaId?: SortOrder
    usuarioId?: SortOrder
    criadoEm?: SortOrder
  }

  export type EscolaUsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    escolaId?: SortOrder
    usuarioId?: SortOrder
    criadoEm?: SortOrder
  }

  export type EscolaUsuarioSumOrderByAggregateInput = {
    id?: SortOrder
    escolaId?: SortOrder
    usuarioId?: SortOrder
  }

  export type AnoEscolarCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AnoEscolarAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AnoEscolarMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AnoEscolarMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AnoEscolarSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AnoEscolarRelationFilter = {
    is?: AnoEscolarWhereInput
    isNot?: AnoEscolarWhereInput
  }

  export type AlunoListRelationFilter = {
    every?: AlunoWhereInput
    some?: AlunoWhereInput
    none?: AlunoWhereInput
  }

  export type AlunoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TurmaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    escolaId?: SortOrder
    anoEscolarId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TurmaAvgOrderByAggregateInput = {
    id?: SortOrder
    escolaId?: SortOrder
    anoEscolarId?: SortOrder
  }

  export type TurmaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    escolaId?: SortOrder
    anoEscolarId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TurmaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    escolaId?: SortOrder
    anoEscolarId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TurmaSumOrderByAggregateInput = {
    id?: SortOrder
    escolaId?: SortOrder
    anoEscolarId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TurmaRelationFilter = {
    is?: TurmaWhereInput
    isNot?: TurmaWhereInput
  }

  export type AlunoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dataNascimento?: SortOrder
    turmaId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AlunoAvgOrderByAggregateInput = {
    id?: SortOrder
    turmaId?: SortOrder
  }

  export type AlunoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dataNascimento?: SortOrder
    turmaId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AlunoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dataNascimento?: SortOrder
    turmaId?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AlunoSumOrderByAggregateInput = {
    id?: SortOrder
    turmaId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EventoAvaliacaoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dataInicio?: SortOrder
    dataFim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type EventoAvaliacaoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EventoAvaliacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dataInicio?: SortOrder
    dataFim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type EventoAvaliacaoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dataInicio?: SortOrder
    dataFim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type EventoAvaliacaoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AlunoRelationFilter = {
    is?: AlunoWhereInput
    isNot?: AlunoWhereInput
  }

  export type EventoAvaliacaoRelationFilter = {
    is?: EventoAvaliacaoWhereInput
    isNot?: EventoAvaliacaoWhereInput
  }

  export type AvaliacaoCountOrderByAggregateInput = {
    id?: SortOrder
    alunoId?: SortOrder
    eventoId?: SortOrder
    aplicadorId?: SortOrder
    palavrasPorMinuto?: SortOrder
    precisao?: SortOrder
    fluencia?: SortOrder
    compreensao?: SortOrder
    nivelLeitura?: SortOrder
    observacoes?: SortOrder
    dataAvaliacao?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AvaliacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    alunoId?: SortOrder
    eventoId?: SortOrder
    aplicadorId?: SortOrder
    palavrasPorMinuto?: SortOrder
    precisao?: SortOrder
    fluencia?: SortOrder
    compreensao?: SortOrder
  }

  export type AvaliacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    alunoId?: SortOrder
    eventoId?: SortOrder
    aplicadorId?: SortOrder
    palavrasPorMinuto?: SortOrder
    precisao?: SortOrder
    fluencia?: SortOrder
    compreensao?: SortOrder
    nivelLeitura?: SortOrder
    observacoes?: SortOrder
    dataAvaliacao?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AvaliacaoMinOrderByAggregateInput = {
    id?: SortOrder
    alunoId?: SortOrder
    eventoId?: SortOrder
    aplicadorId?: SortOrder
    palavrasPorMinuto?: SortOrder
    precisao?: SortOrder
    fluencia?: SortOrder
    compreensao?: SortOrder
    nivelLeitura?: SortOrder
    observacoes?: SortOrder
    dataAvaliacao?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AvaliacaoSumOrderByAggregateInput = {
    id?: SortOrder
    alunoId?: SortOrder
    eventoId?: SortOrder
    aplicadorId?: SortOrder
    palavrasPorMinuto?: SortOrder
    precisao?: SortOrder
    fluencia?: SortOrder
    compreensao?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EscolaUsuarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EscolaUsuarioCreateWithoutUsuarioInput, EscolaUsuarioUncheckedCreateWithoutUsuarioInput> | EscolaUsuarioCreateWithoutUsuarioInput[] | EscolaUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EscolaUsuarioCreateOrConnectWithoutUsuarioInput | EscolaUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: EscolaUsuarioCreateManyUsuarioInputEnvelope
    connect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
  }

  export type AvaliacaoCreateNestedManyWithoutAplicadorInput = {
    create?: XOR<AvaliacaoCreateWithoutAplicadorInput, AvaliacaoUncheckedCreateWithoutAplicadorInput> | AvaliacaoCreateWithoutAplicadorInput[] | AvaliacaoUncheckedCreateWithoutAplicadorInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutAplicadorInput | AvaliacaoCreateOrConnectWithoutAplicadorInput[]
    createMany?: AvaliacaoCreateManyAplicadorInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type EscolaUsuarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EscolaUsuarioCreateWithoutUsuarioInput, EscolaUsuarioUncheckedCreateWithoutUsuarioInput> | EscolaUsuarioCreateWithoutUsuarioInput[] | EscolaUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EscolaUsuarioCreateOrConnectWithoutUsuarioInput | EscolaUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: EscolaUsuarioCreateManyUsuarioInputEnvelope
    connect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutAplicadorInput = {
    create?: XOR<AvaliacaoCreateWithoutAplicadorInput, AvaliacaoUncheckedCreateWithoutAplicadorInput> | AvaliacaoCreateWithoutAplicadorInput[] | AvaliacaoUncheckedCreateWithoutAplicadorInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutAplicadorInput | AvaliacaoCreateOrConnectWithoutAplicadorInput[]
    createMany?: AvaliacaoCreateManyAplicadorInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EscolaUsuarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EscolaUsuarioCreateWithoutUsuarioInput, EscolaUsuarioUncheckedCreateWithoutUsuarioInput> | EscolaUsuarioCreateWithoutUsuarioInput[] | EscolaUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EscolaUsuarioCreateOrConnectWithoutUsuarioInput | EscolaUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: EscolaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | EscolaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EscolaUsuarioCreateManyUsuarioInputEnvelope
    set?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    disconnect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    delete?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    connect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    update?: EscolaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | EscolaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EscolaUsuarioUpdateManyWithWhereWithoutUsuarioInput | EscolaUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EscolaUsuarioScalarWhereInput | EscolaUsuarioScalarWhereInput[]
  }

  export type AvaliacaoUpdateManyWithoutAplicadorNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutAplicadorInput, AvaliacaoUncheckedCreateWithoutAplicadorInput> | AvaliacaoCreateWithoutAplicadorInput[] | AvaliacaoUncheckedCreateWithoutAplicadorInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutAplicadorInput | AvaliacaoCreateOrConnectWithoutAplicadorInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutAplicadorInput | AvaliacaoUpsertWithWhereUniqueWithoutAplicadorInput[]
    createMany?: AvaliacaoCreateManyAplicadorInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutAplicadorInput | AvaliacaoUpdateWithWhereUniqueWithoutAplicadorInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutAplicadorInput | AvaliacaoUpdateManyWithWhereWithoutAplicadorInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EscolaUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EscolaUsuarioCreateWithoutUsuarioInput, EscolaUsuarioUncheckedCreateWithoutUsuarioInput> | EscolaUsuarioCreateWithoutUsuarioInput[] | EscolaUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EscolaUsuarioCreateOrConnectWithoutUsuarioInput | EscolaUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: EscolaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | EscolaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EscolaUsuarioCreateManyUsuarioInputEnvelope
    set?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    disconnect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    delete?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    connect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    update?: EscolaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | EscolaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EscolaUsuarioUpdateManyWithWhereWithoutUsuarioInput | EscolaUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EscolaUsuarioScalarWhereInput | EscolaUsuarioScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutAplicadorNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutAplicadorInput, AvaliacaoUncheckedCreateWithoutAplicadorInput> | AvaliacaoCreateWithoutAplicadorInput[] | AvaliacaoUncheckedCreateWithoutAplicadorInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutAplicadorInput | AvaliacaoCreateOrConnectWithoutAplicadorInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutAplicadorInput | AvaliacaoUpsertWithWhereUniqueWithoutAplicadorInput[]
    createMany?: AvaliacaoCreateManyAplicadorInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutAplicadorInput | AvaliacaoUpdateWithWhereUniqueWithoutAplicadorInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutAplicadorInput | AvaliacaoUpdateManyWithWhereWithoutAplicadorInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type EscolaCreateNestedManyWithoutRegiaoInput = {
    create?: XOR<EscolaCreateWithoutRegiaoInput, EscolaUncheckedCreateWithoutRegiaoInput> | EscolaCreateWithoutRegiaoInput[] | EscolaUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: EscolaCreateOrConnectWithoutRegiaoInput | EscolaCreateOrConnectWithoutRegiaoInput[]
    createMany?: EscolaCreateManyRegiaoInputEnvelope
    connect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
  }

  export type EscolaUncheckedCreateNestedManyWithoutRegiaoInput = {
    create?: XOR<EscolaCreateWithoutRegiaoInput, EscolaUncheckedCreateWithoutRegiaoInput> | EscolaCreateWithoutRegiaoInput[] | EscolaUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: EscolaCreateOrConnectWithoutRegiaoInput | EscolaCreateOrConnectWithoutRegiaoInput[]
    createMany?: EscolaCreateManyRegiaoInputEnvelope
    connect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
  }

  export type EscolaUpdateManyWithoutRegiaoNestedInput = {
    create?: XOR<EscolaCreateWithoutRegiaoInput, EscolaUncheckedCreateWithoutRegiaoInput> | EscolaCreateWithoutRegiaoInput[] | EscolaUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: EscolaCreateOrConnectWithoutRegiaoInput | EscolaCreateOrConnectWithoutRegiaoInput[]
    upsert?: EscolaUpsertWithWhereUniqueWithoutRegiaoInput | EscolaUpsertWithWhereUniqueWithoutRegiaoInput[]
    createMany?: EscolaCreateManyRegiaoInputEnvelope
    set?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    disconnect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    delete?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    connect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    update?: EscolaUpdateWithWhereUniqueWithoutRegiaoInput | EscolaUpdateWithWhereUniqueWithoutRegiaoInput[]
    updateMany?: EscolaUpdateManyWithWhereWithoutRegiaoInput | EscolaUpdateManyWithWhereWithoutRegiaoInput[]
    deleteMany?: EscolaScalarWhereInput | EscolaScalarWhereInput[]
  }

  export type EscolaUncheckedUpdateManyWithoutRegiaoNestedInput = {
    create?: XOR<EscolaCreateWithoutRegiaoInput, EscolaUncheckedCreateWithoutRegiaoInput> | EscolaCreateWithoutRegiaoInput[] | EscolaUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: EscolaCreateOrConnectWithoutRegiaoInput | EscolaCreateOrConnectWithoutRegiaoInput[]
    upsert?: EscolaUpsertWithWhereUniqueWithoutRegiaoInput | EscolaUpsertWithWhereUniqueWithoutRegiaoInput[]
    createMany?: EscolaCreateManyRegiaoInputEnvelope
    set?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    disconnect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    delete?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    connect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    update?: EscolaUpdateWithWhereUniqueWithoutRegiaoInput | EscolaUpdateWithWhereUniqueWithoutRegiaoInput[]
    updateMany?: EscolaUpdateManyWithWhereWithoutRegiaoInput | EscolaUpdateManyWithWhereWithoutRegiaoInput[]
    deleteMany?: EscolaScalarWhereInput | EscolaScalarWhereInput[]
  }

  export type EscolaCreateNestedManyWithoutGrupoInput = {
    create?: XOR<EscolaCreateWithoutGrupoInput, EscolaUncheckedCreateWithoutGrupoInput> | EscolaCreateWithoutGrupoInput[] | EscolaUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: EscolaCreateOrConnectWithoutGrupoInput | EscolaCreateOrConnectWithoutGrupoInput[]
    createMany?: EscolaCreateManyGrupoInputEnvelope
    connect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
  }

  export type EscolaUncheckedCreateNestedManyWithoutGrupoInput = {
    create?: XOR<EscolaCreateWithoutGrupoInput, EscolaUncheckedCreateWithoutGrupoInput> | EscolaCreateWithoutGrupoInput[] | EscolaUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: EscolaCreateOrConnectWithoutGrupoInput | EscolaCreateOrConnectWithoutGrupoInput[]
    createMany?: EscolaCreateManyGrupoInputEnvelope
    connect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
  }

  export type EscolaUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<EscolaCreateWithoutGrupoInput, EscolaUncheckedCreateWithoutGrupoInput> | EscolaCreateWithoutGrupoInput[] | EscolaUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: EscolaCreateOrConnectWithoutGrupoInput | EscolaCreateOrConnectWithoutGrupoInput[]
    upsert?: EscolaUpsertWithWhereUniqueWithoutGrupoInput | EscolaUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: EscolaCreateManyGrupoInputEnvelope
    set?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    disconnect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    delete?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    connect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    update?: EscolaUpdateWithWhereUniqueWithoutGrupoInput | EscolaUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: EscolaUpdateManyWithWhereWithoutGrupoInput | EscolaUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: EscolaScalarWhereInput | EscolaScalarWhereInput[]
  }

  export type EscolaUncheckedUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<EscolaCreateWithoutGrupoInput, EscolaUncheckedCreateWithoutGrupoInput> | EscolaCreateWithoutGrupoInput[] | EscolaUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: EscolaCreateOrConnectWithoutGrupoInput | EscolaCreateOrConnectWithoutGrupoInput[]
    upsert?: EscolaUpsertWithWhereUniqueWithoutGrupoInput | EscolaUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: EscolaCreateManyGrupoInputEnvelope
    set?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    disconnect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    delete?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    connect?: EscolaWhereUniqueInput | EscolaWhereUniqueInput[]
    update?: EscolaUpdateWithWhereUniqueWithoutGrupoInput | EscolaUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: EscolaUpdateManyWithWhereWithoutGrupoInput | EscolaUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: EscolaScalarWhereInput | EscolaScalarWhereInput[]
  }

  export type RegiaoCreateNestedOneWithoutEscolasInput = {
    create?: XOR<RegiaoCreateWithoutEscolasInput, RegiaoUncheckedCreateWithoutEscolasInput>
    connectOrCreate?: RegiaoCreateOrConnectWithoutEscolasInput
    connect?: RegiaoWhereUniqueInput
  }

  export type GrupoCreateNestedOneWithoutEscolasInput = {
    create?: XOR<GrupoCreateWithoutEscolasInput, GrupoUncheckedCreateWithoutEscolasInput>
    connectOrCreate?: GrupoCreateOrConnectWithoutEscolasInput
    connect?: GrupoWhereUniqueInput
  }

  export type TurmaCreateNestedManyWithoutEscolaInput = {
    create?: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput> | TurmaCreateWithoutEscolaInput[] | TurmaUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutEscolaInput | TurmaCreateOrConnectWithoutEscolaInput[]
    createMany?: TurmaCreateManyEscolaInputEnvelope
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
  }

  export type EscolaUsuarioCreateNestedManyWithoutEscolaInput = {
    create?: XOR<EscolaUsuarioCreateWithoutEscolaInput, EscolaUsuarioUncheckedCreateWithoutEscolaInput> | EscolaUsuarioCreateWithoutEscolaInput[] | EscolaUsuarioUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: EscolaUsuarioCreateOrConnectWithoutEscolaInput | EscolaUsuarioCreateOrConnectWithoutEscolaInput[]
    createMany?: EscolaUsuarioCreateManyEscolaInputEnvelope
    connect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
  }

  export type TurmaUncheckedCreateNestedManyWithoutEscolaInput = {
    create?: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput> | TurmaCreateWithoutEscolaInput[] | TurmaUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutEscolaInput | TurmaCreateOrConnectWithoutEscolaInput[]
    createMany?: TurmaCreateManyEscolaInputEnvelope
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
  }

  export type EscolaUsuarioUncheckedCreateNestedManyWithoutEscolaInput = {
    create?: XOR<EscolaUsuarioCreateWithoutEscolaInput, EscolaUsuarioUncheckedCreateWithoutEscolaInput> | EscolaUsuarioCreateWithoutEscolaInput[] | EscolaUsuarioUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: EscolaUsuarioCreateOrConnectWithoutEscolaInput | EscolaUsuarioCreateOrConnectWithoutEscolaInput[]
    createMany?: EscolaUsuarioCreateManyEscolaInputEnvelope
    connect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
  }

  export type RegiaoUpdateOneRequiredWithoutEscolasNestedInput = {
    create?: XOR<RegiaoCreateWithoutEscolasInput, RegiaoUncheckedCreateWithoutEscolasInput>
    connectOrCreate?: RegiaoCreateOrConnectWithoutEscolasInput
    upsert?: RegiaoUpsertWithoutEscolasInput
    connect?: RegiaoWhereUniqueInput
    update?: XOR<XOR<RegiaoUpdateToOneWithWhereWithoutEscolasInput, RegiaoUpdateWithoutEscolasInput>, RegiaoUncheckedUpdateWithoutEscolasInput>
  }

  export type GrupoUpdateOneWithoutEscolasNestedInput = {
    create?: XOR<GrupoCreateWithoutEscolasInput, GrupoUncheckedCreateWithoutEscolasInput>
    connectOrCreate?: GrupoCreateOrConnectWithoutEscolasInput
    upsert?: GrupoUpsertWithoutEscolasInput
    disconnect?: GrupoWhereInput | boolean
    delete?: GrupoWhereInput | boolean
    connect?: GrupoWhereUniqueInput
    update?: XOR<XOR<GrupoUpdateToOneWithWhereWithoutEscolasInput, GrupoUpdateWithoutEscolasInput>, GrupoUncheckedUpdateWithoutEscolasInput>
  }

  export type TurmaUpdateManyWithoutEscolaNestedInput = {
    create?: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput> | TurmaCreateWithoutEscolaInput[] | TurmaUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutEscolaInput | TurmaCreateOrConnectWithoutEscolaInput[]
    upsert?: TurmaUpsertWithWhereUniqueWithoutEscolaInput | TurmaUpsertWithWhereUniqueWithoutEscolaInput[]
    createMany?: TurmaCreateManyEscolaInputEnvelope
    set?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    disconnect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    delete?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    update?: TurmaUpdateWithWhereUniqueWithoutEscolaInput | TurmaUpdateWithWhereUniqueWithoutEscolaInput[]
    updateMany?: TurmaUpdateManyWithWhereWithoutEscolaInput | TurmaUpdateManyWithWhereWithoutEscolaInput[]
    deleteMany?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
  }

  export type EscolaUsuarioUpdateManyWithoutEscolaNestedInput = {
    create?: XOR<EscolaUsuarioCreateWithoutEscolaInput, EscolaUsuarioUncheckedCreateWithoutEscolaInput> | EscolaUsuarioCreateWithoutEscolaInput[] | EscolaUsuarioUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: EscolaUsuarioCreateOrConnectWithoutEscolaInput | EscolaUsuarioCreateOrConnectWithoutEscolaInput[]
    upsert?: EscolaUsuarioUpsertWithWhereUniqueWithoutEscolaInput | EscolaUsuarioUpsertWithWhereUniqueWithoutEscolaInput[]
    createMany?: EscolaUsuarioCreateManyEscolaInputEnvelope
    set?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    disconnect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    delete?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    connect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    update?: EscolaUsuarioUpdateWithWhereUniqueWithoutEscolaInput | EscolaUsuarioUpdateWithWhereUniqueWithoutEscolaInput[]
    updateMany?: EscolaUsuarioUpdateManyWithWhereWithoutEscolaInput | EscolaUsuarioUpdateManyWithWhereWithoutEscolaInput[]
    deleteMany?: EscolaUsuarioScalarWhereInput | EscolaUsuarioScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TurmaUncheckedUpdateManyWithoutEscolaNestedInput = {
    create?: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput> | TurmaCreateWithoutEscolaInput[] | TurmaUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutEscolaInput | TurmaCreateOrConnectWithoutEscolaInput[]
    upsert?: TurmaUpsertWithWhereUniqueWithoutEscolaInput | TurmaUpsertWithWhereUniqueWithoutEscolaInput[]
    createMany?: TurmaCreateManyEscolaInputEnvelope
    set?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    disconnect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    delete?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    update?: TurmaUpdateWithWhereUniqueWithoutEscolaInput | TurmaUpdateWithWhereUniqueWithoutEscolaInput[]
    updateMany?: TurmaUpdateManyWithWhereWithoutEscolaInput | TurmaUpdateManyWithWhereWithoutEscolaInput[]
    deleteMany?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
  }

  export type EscolaUsuarioUncheckedUpdateManyWithoutEscolaNestedInput = {
    create?: XOR<EscolaUsuarioCreateWithoutEscolaInput, EscolaUsuarioUncheckedCreateWithoutEscolaInput> | EscolaUsuarioCreateWithoutEscolaInput[] | EscolaUsuarioUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: EscolaUsuarioCreateOrConnectWithoutEscolaInput | EscolaUsuarioCreateOrConnectWithoutEscolaInput[]
    upsert?: EscolaUsuarioUpsertWithWhereUniqueWithoutEscolaInput | EscolaUsuarioUpsertWithWhereUniqueWithoutEscolaInput[]
    createMany?: EscolaUsuarioCreateManyEscolaInputEnvelope
    set?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    disconnect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    delete?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    connect?: EscolaUsuarioWhereUniqueInput | EscolaUsuarioWhereUniqueInput[]
    update?: EscolaUsuarioUpdateWithWhereUniqueWithoutEscolaInput | EscolaUsuarioUpdateWithWhereUniqueWithoutEscolaInput[]
    updateMany?: EscolaUsuarioUpdateManyWithWhereWithoutEscolaInput | EscolaUsuarioUpdateManyWithWhereWithoutEscolaInput[]
    deleteMany?: EscolaUsuarioScalarWhereInput | EscolaUsuarioScalarWhereInput[]
  }

  export type EscolaCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<EscolaCreateWithoutUsuariosInput, EscolaUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: EscolaCreateOrConnectWithoutUsuariosInput
    connect?: EscolaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutEscolasInput = {
    create?: XOR<UsuarioCreateWithoutEscolasInput, UsuarioUncheckedCreateWithoutEscolasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEscolasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EscolaUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<EscolaCreateWithoutUsuariosInput, EscolaUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: EscolaCreateOrConnectWithoutUsuariosInput
    upsert?: EscolaUpsertWithoutUsuariosInput
    connect?: EscolaWhereUniqueInput
    update?: XOR<XOR<EscolaUpdateToOneWithWhereWithoutUsuariosInput, EscolaUpdateWithoutUsuariosInput>, EscolaUncheckedUpdateWithoutUsuariosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutEscolasNestedInput = {
    create?: XOR<UsuarioCreateWithoutEscolasInput, UsuarioUncheckedCreateWithoutEscolasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEscolasInput
    upsert?: UsuarioUpsertWithoutEscolasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEscolasInput, UsuarioUpdateWithoutEscolasInput>, UsuarioUncheckedUpdateWithoutEscolasInput>
  }

  export type TurmaCreateNestedManyWithoutAnoEscolarInput = {
    create?: XOR<TurmaCreateWithoutAnoEscolarInput, TurmaUncheckedCreateWithoutAnoEscolarInput> | TurmaCreateWithoutAnoEscolarInput[] | TurmaUncheckedCreateWithoutAnoEscolarInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutAnoEscolarInput | TurmaCreateOrConnectWithoutAnoEscolarInput[]
    createMany?: TurmaCreateManyAnoEscolarInputEnvelope
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
  }

  export type TurmaUncheckedCreateNestedManyWithoutAnoEscolarInput = {
    create?: XOR<TurmaCreateWithoutAnoEscolarInput, TurmaUncheckedCreateWithoutAnoEscolarInput> | TurmaCreateWithoutAnoEscolarInput[] | TurmaUncheckedCreateWithoutAnoEscolarInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutAnoEscolarInput | TurmaCreateOrConnectWithoutAnoEscolarInput[]
    createMany?: TurmaCreateManyAnoEscolarInputEnvelope
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
  }

  export type TurmaUpdateManyWithoutAnoEscolarNestedInput = {
    create?: XOR<TurmaCreateWithoutAnoEscolarInput, TurmaUncheckedCreateWithoutAnoEscolarInput> | TurmaCreateWithoutAnoEscolarInput[] | TurmaUncheckedCreateWithoutAnoEscolarInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutAnoEscolarInput | TurmaCreateOrConnectWithoutAnoEscolarInput[]
    upsert?: TurmaUpsertWithWhereUniqueWithoutAnoEscolarInput | TurmaUpsertWithWhereUniqueWithoutAnoEscolarInput[]
    createMany?: TurmaCreateManyAnoEscolarInputEnvelope
    set?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    disconnect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    delete?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    update?: TurmaUpdateWithWhereUniqueWithoutAnoEscolarInput | TurmaUpdateWithWhereUniqueWithoutAnoEscolarInput[]
    updateMany?: TurmaUpdateManyWithWhereWithoutAnoEscolarInput | TurmaUpdateManyWithWhereWithoutAnoEscolarInput[]
    deleteMany?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
  }

  export type TurmaUncheckedUpdateManyWithoutAnoEscolarNestedInput = {
    create?: XOR<TurmaCreateWithoutAnoEscolarInput, TurmaUncheckedCreateWithoutAnoEscolarInput> | TurmaCreateWithoutAnoEscolarInput[] | TurmaUncheckedCreateWithoutAnoEscolarInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutAnoEscolarInput | TurmaCreateOrConnectWithoutAnoEscolarInput[]
    upsert?: TurmaUpsertWithWhereUniqueWithoutAnoEscolarInput | TurmaUpsertWithWhereUniqueWithoutAnoEscolarInput[]
    createMany?: TurmaCreateManyAnoEscolarInputEnvelope
    set?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    disconnect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    delete?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    update?: TurmaUpdateWithWhereUniqueWithoutAnoEscolarInput | TurmaUpdateWithWhereUniqueWithoutAnoEscolarInput[]
    updateMany?: TurmaUpdateManyWithWhereWithoutAnoEscolarInput | TurmaUpdateManyWithWhereWithoutAnoEscolarInput[]
    deleteMany?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
  }

  export type EscolaCreateNestedOneWithoutTurmasInput = {
    create?: XOR<EscolaCreateWithoutTurmasInput, EscolaUncheckedCreateWithoutTurmasInput>
    connectOrCreate?: EscolaCreateOrConnectWithoutTurmasInput
    connect?: EscolaWhereUniqueInput
  }

  export type AnoEscolarCreateNestedOneWithoutTurmasInput = {
    create?: XOR<AnoEscolarCreateWithoutTurmasInput, AnoEscolarUncheckedCreateWithoutTurmasInput>
    connectOrCreate?: AnoEscolarCreateOrConnectWithoutTurmasInput
    connect?: AnoEscolarWhereUniqueInput
  }

  export type AlunoCreateNestedManyWithoutTurmaInput = {
    create?: XOR<AlunoCreateWithoutTurmaInput, AlunoUncheckedCreateWithoutTurmaInput> | AlunoCreateWithoutTurmaInput[] | AlunoUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: AlunoCreateOrConnectWithoutTurmaInput | AlunoCreateOrConnectWithoutTurmaInput[]
    createMany?: AlunoCreateManyTurmaInputEnvelope
    connect?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
  }

  export type AlunoUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<AlunoCreateWithoutTurmaInput, AlunoUncheckedCreateWithoutTurmaInput> | AlunoCreateWithoutTurmaInput[] | AlunoUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: AlunoCreateOrConnectWithoutTurmaInput | AlunoCreateOrConnectWithoutTurmaInput[]
    createMany?: AlunoCreateManyTurmaInputEnvelope
    connect?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
  }

  export type EscolaUpdateOneRequiredWithoutTurmasNestedInput = {
    create?: XOR<EscolaCreateWithoutTurmasInput, EscolaUncheckedCreateWithoutTurmasInput>
    connectOrCreate?: EscolaCreateOrConnectWithoutTurmasInput
    upsert?: EscolaUpsertWithoutTurmasInput
    connect?: EscolaWhereUniqueInput
    update?: XOR<XOR<EscolaUpdateToOneWithWhereWithoutTurmasInput, EscolaUpdateWithoutTurmasInput>, EscolaUncheckedUpdateWithoutTurmasInput>
  }

  export type AnoEscolarUpdateOneRequiredWithoutTurmasNestedInput = {
    create?: XOR<AnoEscolarCreateWithoutTurmasInput, AnoEscolarUncheckedCreateWithoutTurmasInput>
    connectOrCreate?: AnoEscolarCreateOrConnectWithoutTurmasInput
    upsert?: AnoEscolarUpsertWithoutTurmasInput
    connect?: AnoEscolarWhereUniqueInput
    update?: XOR<XOR<AnoEscolarUpdateToOneWithWhereWithoutTurmasInput, AnoEscolarUpdateWithoutTurmasInput>, AnoEscolarUncheckedUpdateWithoutTurmasInput>
  }

  export type AlunoUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<AlunoCreateWithoutTurmaInput, AlunoUncheckedCreateWithoutTurmaInput> | AlunoCreateWithoutTurmaInput[] | AlunoUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: AlunoCreateOrConnectWithoutTurmaInput | AlunoCreateOrConnectWithoutTurmaInput[]
    upsert?: AlunoUpsertWithWhereUniqueWithoutTurmaInput | AlunoUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: AlunoCreateManyTurmaInputEnvelope
    set?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
    disconnect?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
    delete?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
    connect?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
    update?: AlunoUpdateWithWhereUniqueWithoutTurmaInput | AlunoUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: AlunoUpdateManyWithWhereWithoutTurmaInput | AlunoUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: AlunoScalarWhereInput | AlunoScalarWhereInput[]
  }

  export type AlunoUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<AlunoCreateWithoutTurmaInput, AlunoUncheckedCreateWithoutTurmaInput> | AlunoCreateWithoutTurmaInput[] | AlunoUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: AlunoCreateOrConnectWithoutTurmaInput | AlunoCreateOrConnectWithoutTurmaInput[]
    upsert?: AlunoUpsertWithWhereUniqueWithoutTurmaInput | AlunoUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: AlunoCreateManyTurmaInputEnvelope
    set?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
    disconnect?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
    delete?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
    connect?: AlunoWhereUniqueInput | AlunoWhereUniqueInput[]
    update?: AlunoUpdateWithWhereUniqueWithoutTurmaInput | AlunoUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: AlunoUpdateManyWithWhereWithoutTurmaInput | AlunoUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: AlunoScalarWhereInput | AlunoScalarWhereInput[]
  }

  export type TurmaCreateNestedOneWithoutAlunosInput = {
    create?: XOR<TurmaCreateWithoutAlunosInput, TurmaUncheckedCreateWithoutAlunosInput>
    connectOrCreate?: TurmaCreateOrConnectWithoutAlunosInput
    connect?: TurmaWhereUniqueInput
  }

  export type AvaliacaoCreateNestedManyWithoutAlunoInput = {
    create?: XOR<AvaliacaoCreateWithoutAlunoInput, AvaliacaoUncheckedCreateWithoutAlunoInput> | AvaliacaoCreateWithoutAlunoInput[] | AvaliacaoUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutAlunoInput | AvaliacaoCreateOrConnectWithoutAlunoInput[]
    createMany?: AvaliacaoCreateManyAlunoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutAlunoInput = {
    create?: XOR<AvaliacaoCreateWithoutAlunoInput, AvaliacaoUncheckedCreateWithoutAlunoInput> | AvaliacaoCreateWithoutAlunoInput[] | AvaliacaoUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutAlunoInput | AvaliacaoCreateOrConnectWithoutAlunoInput[]
    createMany?: AvaliacaoCreateManyAlunoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TurmaUpdateOneRequiredWithoutAlunosNestedInput = {
    create?: XOR<TurmaCreateWithoutAlunosInput, TurmaUncheckedCreateWithoutAlunosInput>
    connectOrCreate?: TurmaCreateOrConnectWithoutAlunosInput
    upsert?: TurmaUpsertWithoutAlunosInput
    connect?: TurmaWhereUniqueInput
    update?: XOR<XOR<TurmaUpdateToOneWithWhereWithoutAlunosInput, TurmaUpdateWithoutAlunosInput>, TurmaUncheckedUpdateWithoutAlunosInput>
  }

  export type AvaliacaoUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutAlunoInput, AvaliacaoUncheckedCreateWithoutAlunoInput> | AvaliacaoCreateWithoutAlunoInput[] | AvaliacaoUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutAlunoInput | AvaliacaoCreateOrConnectWithoutAlunoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutAlunoInput | AvaliacaoUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: AvaliacaoCreateManyAlunoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutAlunoInput | AvaliacaoUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutAlunoInput | AvaliacaoUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutAlunoInput, AvaliacaoUncheckedCreateWithoutAlunoInput> | AvaliacaoCreateWithoutAlunoInput[] | AvaliacaoUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutAlunoInput | AvaliacaoCreateOrConnectWithoutAlunoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutAlunoInput | AvaliacaoUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: AvaliacaoCreateManyAlunoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutAlunoInput | AvaliacaoUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutAlunoInput | AvaliacaoUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type AvaliacaoCreateNestedManyWithoutEventoInput = {
    create?: XOR<AvaliacaoCreateWithoutEventoInput, AvaliacaoUncheckedCreateWithoutEventoInput> | AvaliacaoCreateWithoutEventoInput[] | AvaliacaoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutEventoInput | AvaliacaoCreateOrConnectWithoutEventoInput[]
    createMany?: AvaliacaoCreateManyEventoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutEventoInput = {
    create?: XOR<AvaliacaoCreateWithoutEventoInput, AvaliacaoUncheckedCreateWithoutEventoInput> | AvaliacaoCreateWithoutEventoInput[] | AvaliacaoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutEventoInput | AvaliacaoCreateOrConnectWithoutEventoInput[]
    createMany?: AvaliacaoCreateManyEventoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type AvaliacaoUpdateManyWithoutEventoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutEventoInput, AvaliacaoUncheckedCreateWithoutEventoInput> | AvaliacaoCreateWithoutEventoInput[] | AvaliacaoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutEventoInput | AvaliacaoCreateOrConnectWithoutEventoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutEventoInput | AvaliacaoUpsertWithWhereUniqueWithoutEventoInput[]
    createMany?: AvaliacaoCreateManyEventoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutEventoInput | AvaliacaoUpdateWithWhereUniqueWithoutEventoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutEventoInput | AvaliacaoUpdateManyWithWhereWithoutEventoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutEventoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutEventoInput, AvaliacaoUncheckedCreateWithoutEventoInput> | AvaliacaoCreateWithoutEventoInput[] | AvaliacaoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutEventoInput | AvaliacaoCreateOrConnectWithoutEventoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutEventoInput | AvaliacaoUpsertWithWhereUniqueWithoutEventoInput[]
    createMany?: AvaliacaoCreateManyEventoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutEventoInput | AvaliacaoUpdateWithWhereUniqueWithoutEventoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutEventoInput | AvaliacaoUpdateManyWithWhereWithoutEventoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type AlunoCreateNestedOneWithoutAvaliacoesInput = {
    create?: XOR<AlunoCreateWithoutAvaliacoesInput, AlunoUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: AlunoCreateOrConnectWithoutAvaliacoesInput
    connect?: AlunoWhereUniqueInput
  }

  export type EventoAvaliacaoCreateNestedOneWithoutAvaliacoesInput = {
    create?: XOR<EventoAvaliacaoCreateWithoutAvaliacoesInput, EventoAvaliacaoUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: EventoAvaliacaoCreateOrConnectWithoutAvaliacoesInput
    connect?: EventoAvaliacaoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutAvaliacoesAplicadasInput = {
    create?: XOR<UsuarioCreateWithoutAvaliacoesAplicadasInput, UsuarioUncheckedCreateWithoutAvaliacoesAplicadasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAvaliacoesAplicadasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AlunoUpdateOneRequiredWithoutAvaliacoesNestedInput = {
    create?: XOR<AlunoCreateWithoutAvaliacoesInput, AlunoUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: AlunoCreateOrConnectWithoutAvaliacoesInput
    upsert?: AlunoUpsertWithoutAvaliacoesInput
    connect?: AlunoWhereUniqueInput
    update?: XOR<XOR<AlunoUpdateToOneWithWhereWithoutAvaliacoesInput, AlunoUpdateWithoutAvaliacoesInput>, AlunoUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type EventoAvaliacaoUpdateOneRequiredWithoutAvaliacoesNestedInput = {
    create?: XOR<EventoAvaliacaoCreateWithoutAvaliacoesInput, EventoAvaliacaoUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: EventoAvaliacaoCreateOrConnectWithoutAvaliacoesInput
    upsert?: EventoAvaliacaoUpsertWithoutAvaliacoesInput
    connect?: EventoAvaliacaoWhereUniqueInput
    update?: XOR<XOR<EventoAvaliacaoUpdateToOneWithWhereWithoutAvaliacoesInput, EventoAvaliacaoUpdateWithoutAvaliacoesInput>, EventoAvaliacaoUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutAvaliacoesAplicadasNestedInput = {
    create?: XOR<UsuarioCreateWithoutAvaliacoesAplicadasInput, UsuarioUncheckedCreateWithoutAvaliacoesAplicadasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAvaliacoesAplicadasInput
    upsert?: UsuarioUpsertWithoutAvaliacoesAplicadasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutAvaliacoesAplicadasInput, UsuarioUpdateWithoutAvaliacoesAplicadasInput>, UsuarioUncheckedUpdateWithoutAvaliacoesAplicadasInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EscolaUsuarioCreateWithoutUsuarioInput = {
    criadoEm?: Date | string
    escola: EscolaCreateNestedOneWithoutUsuariosInput
  }

  export type EscolaUsuarioUncheckedCreateWithoutUsuarioInput = {
    id?: number
    escolaId: number
    criadoEm?: Date | string
  }

  export type EscolaUsuarioCreateOrConnectWithoutUsuarioInput = {
    where: EscolaUsuarioWhereUniqueInput
    create: XOR<EscolaUsuarioCreateWithoutUsuarioInput, EscolaUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type EscolaUsuarioCreateManyUsuarioInputEnvelope = {
    data: EscolaUsuarioCreateManyUsuarioInput | EscolaUsuarioCreateManyUsuarioInput[]
  }

  export type AvaliacaoCreateWithoutAplicadorInput = {
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    aluno: AlunoCreateNestedOneWithoutAvaliacoesInput
    evento: EventoAvaliacaoCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutAplicadorInput = {
    id?: number
    alunoId: number
    eventoId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AvaliacaoCreateOrConnectWithoutAplicadorInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutAplicadorInput, AvaliacaoUncheckedCreateWithoutAplicadorInput>
  }

  export type AvaliacaoCreateManyAplicadorInputEnvelope = {
    data: AvaliacaoCreateManyAplicadorInput | AvaliacaoCreateManyAplicadorInput[]
  }

  export type EscolaUsuarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: EscolaUsuarioWhereUniqueInput
    update: XOR<EscolaUsuarioUpdateWithoutUsuarioInput, EscolaUsuarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EscolaUsuarioCreateWithoutUsuarioInput, EscolaUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type EscolaUsuarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: EscolaUsuarioWhereUniqueInput
    data: XOR<EscolaUsuarioUpdateWithoutUsuarioInput, EscolaUsuarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type EscolaUsuarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: EscolaUsuarioScalarWhereInput
    data: XOR<EscolaUsuarioUpdateManyMutationInput, EscolaUsuarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type EscolaUsuarioScalarWhereInput = {
    AND?: EscolaUsuarioScalarWhereInput | EscolaUsuarioScalarWhereInput[]
    OR?: EscolaUsuarioScalarWhereInput[]
    NOT?: EscolaUsuarioScalarWhereInput | EscolaUsuarioScalarWhereInput[]
    id?: IntFilter<"EscolaUsuario"> | number
    escolaId?: IntFilter<"EscolaUsuario"> | number
    usuarioId?: IntFilter<"EscolaUsuario"> | number
    criadoEm?: DateTimeFilter<"EscolaUsuario"> | Date | string
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutAplicadorInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutAplicadorInput, AvaliacaoUncheckedUpdateWithoutAplicadorInput>
    create: XOR<AvaliacaoCreateWithoutAplicadorInput, AvaliacaoUncheckedCreateWithoutAplicadorInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutAplicadorInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutAplicadorInput, AvaliacaoUncheckedUpdateWithoutAplicadorInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutAplicadorInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutAplicadorInput>
  }

  export type AvaliacaoScalarWhereInput = {
    AND?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
    OR?: AvaliacaoScalarWhereInput[]
    NOT?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
    id?: IntFilter<"Avaliacao"> | number
    alunoId?: IntFilter<"Avaliacao"> | number
    eventoId?: IntFilter<"Avaliacao"> | number
    aplicadorId?: IntFilter<"Avaliacao"> | number
    palavrasPorMinuto?: IntFilter<"Avaliacao"> | number
    precisao?: FloatFilter<"Avaliacao"> | number
    fluencia?: FloatFilter<"Avaliacao"> | number
    compreensao?: FloatFilter<"Avaliacao"> | number
    nivelLeitura?: StringFilter<"Avaliacao"> | string
    observacoes?: StringNullableFilter<"Avaliacao"> | string | null
    dataAvaliacao?: DateTimeFilter<"Avaliacao"> | Date | string
    criadoEm?: DateTimeFilter<"Avaliacao"> | Date | string
    atualizadoEm?: DateTimeFilter<"Avaliacao"> | Date | string
  }

  export type EscolaCreateWithoutRegiaoInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    grupo?: GrupoCreateNestedOneWithoutEscolasInput
    turmas?: TurmaCreateNestedManyWithoutEscolaInput
    usuarios?: EscolaUsuarioCreateNestedManyWithoutEscolaInput
  }

  export type EscolaUncheckedCreateWithoutRegiaoInput = {
    id?: number
    nome: string
    grupoId?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    turmas?: TurmaUncheckedCreateNestedManyWithoutEscolaInput
    usuarios?: EscolaUsuarioUncheckedCreateNestedManyWithoutEscolaInput
  }

  export type EscolaCreateOrConnectWithoutRegiaoInput = {
    where: EscolaWhereUniqueInput
    create: XOR<EscolaCreateWithoutRegiaoInput, EscolaUncheckedCreateWithoutRegiaoInput>
  }

  export type EscolaCreateManyRegiaoInputEnvelope = {
    data: EscolaCreateManyRegiaoInput | EscolaCreateManyRegiaoInput[]
  }

  export type EscolaUpsertWithWhereUniqueWithoutRegiaoInput = {
    where: EscolaWhereUniqueInput
    update: XOR<EscolaUpdateWithoutRegiaoInput, EscolaUncheckedUpdateWithoutRegiaoInput>
    create: XOR<EscolaCreateWithoutRegiaoInput, EscolaUncheckedCreateWithoutRegiaoInput>
  }

  export type EscolaUpdateWithWhereUniqueWithoutRegiaoInput = {
    where: EscolaWhereUniqueInput
    data: XOR<EscolaUpdateWithoutRegiaoInput, EscolaUncheckedUpdateWithoutRegiaoInput>
  }

  export type EscolaUpdateManyWithWhereWithoutRegiaoInput = {
    where: EscolaScalarWhereInput
    data: XOR<EscolaUpdateManyMutationInput, EscolaUncheckedUpdateManyWithoutRegiaoInput>
  }

  export type EscolaScalarWhereInput = {
    AND?: EscolaScalarWhereInput | EscolaScalarWhereInput[]
    OR?: EscolaScalarWhereInput[]
    NOT?: EscolaScalarWhereInput | EscolaScalarWhereInput[]
    id?: IntFilter<"Escola"> | number
    nome?: StringFilter<"Escola"> | string
    regiaoId?: IntFilter<"Escola"> | number
    grupoId?: IntNullableFilter<"Escola"> | number | null
    criadoEm?: DateTimeFilter<"Escola"> | Date | string
    atualizadoEm?: DateTimeFilter<"Escola"> | Date | string
  }

  export type EscolaCreateWithoutGrupoInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    regiao: RegiaoCreateNestedOneWithoutEscolasInput
    turmas?: TurmaCreateNestedManyWithoutEscolaInput
    usuarios?: EscolaUsuarioCreateNestedManyWithoutEscolaInput
  }

  export type EscolaUncheckedCreateWithoutGrupoInput = {
    id?: number
    nome: string
    regiaoId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    turmas?: TurmaUncheckedCreateNestedManyWithoutEscolaInput
    usuarios?: EscolaUsuarioUncheckedCreateNestedManyWithoutEscolaInput
  }

  export type EscolaCreateOrConnectWithoutGrupoInput = {
    where: EscolaWhereUniqueInput
    create: XOR<EscolaCreateWithoutGrupoInput, EscolaUncheckedCreateWithoutGrupoInput>
  }

  export type EscolaCreateManyGrupoInputEnvelope = {
    data: EscolaCreateManyGrupoInput | EscolaCreateManyGrupoInput[]
  }

  export type EscolaUpsertWithWhereUniqueWithoutGrupoInput = {
    where: EscolaWhereUniqueInput
    update: XOR<EscolaUpdateWithoutGrupoInput, EscolaUncheckedUpdateWithoutGrupoInput>
    create: XOR<EscolaCreateWithoutGrupoInput, EscolaUncheckedCreateWithoutGrupoInput>
  }

  export type EscolaUpdateWithWhereUniqueWithoutGrupoInput = {
    where: EscolaWhereUniqueInput
    data: XOR<EscolaUpdateWithoutGrupoInput, EscolaUncheckedUpdateWithoutGrupoInput>
  }

  export type EscolaUpdateManyWithWhereWithoutGrupoInput = {
    where: EscolaScalarWhereInput
    data: XOR<EscolaUpdateManyMutationInput, EscolaUncheckedUpdateManyWithoutGrupoInput>
  }

  export type RegiaoCreateWithoutEscolasInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type RegiaoUncheckedCreateWithoutEscolasInput = {
    id?: number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type RegiaoCreateOrConnectWithoutEscolasInput = {
    where: RegiaoWhereUniqueInput
    create: XOR<RegiaoCreateWithoutEscolasInput, RegiaoUncheckedCreateWithoutEscolasInput>
  }

  export type GrupoCreateWithoutEscolasInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type GrupoUncheckedCreateWithoutEscolasInput = {
    id?: number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type GrupoCreateOrConnectWithoutEscolasInput = {
    where: GrupoWhereUniqueInput
    create: XOR<GrupoCreateWithoutEscolasInput, GrupoUncheckedCreateWithoutEscolasInput>
  }

  export type TurmaCreateWithoutEscolaInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    anoEscolar: AnoEscolarCreateNestedOneWithoutTurmasInput
    alunos?: AlunoCreateNestedManyWithoutTurmaInput
  }

  export type TurmaUncheckedCreateWithoutEscolaInput = {
    id?: number
    nome: string
    anoEscolarId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    alunos?: AlunoUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type TurmaCreateOrConnectWithoutEscolaInput = {
    where: TurmaWhereUniqueInput
    create: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput>
  }

  export type TurmaCreateManyEscolaInputEnvelope = {
    data: TurmaCreateManyEscolaInput | TurmaCreateManyEscolaInput[]
  }

  export type EscolaUsuarioCreateWithoutEscolaInput = {
    criadoEm?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEscolasInput
  }

  export type EscolaUsuarioUncheckedCreateWithoutEscolaInput = {
    id?: number
    usuarioId: number
    criadoEm?: Date | string
  }

  export type EscolaUsuarioCreateOrConnectWithoutEscolaInput = {
    where: EscolaUsuarioWhereUniqueInput
    create: XOR<EscolaUsuarioCreateWithoutEscolaInput, EscolaUsuarioUncheckedCreateWithoutEscolaInput>
  }

  export type EscolaUsuarioCreateManyEscolaInputEnvelope = {
    data: EscolaUsuarioCreateManyEscolaInput | EscolaUsuarioCreateManyEscolaInput[]
  }

  export type RegiaoUpsertWithoutEscolasInput = {
    update: XOR<RegiaoUpdateWithoutEscolasInput, RegiaoUncheckedUpdateWithoutEscolasInput>
    create: XOR<RegiaoCreateWithoutEscolasInput, RegiaoUncheckedCreateWithoutEscolasInput>
    where?: RegiaoWhereInput
  }

  export type RegiaoUpdateToOneWithWhereWithoutEscolasInput = {
    where?: RegiaoWhereInput
    data: XOR<RegiaoUpdateWithoutEscolasInput, RegiaoUncheckedUpdateWithoutEscolasInput>
  }

  export type RegiaoUpdateWithoutEscolasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegiaoUncheckedUpdateWithoutEscolasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrupoUpsertWithoutEscolasInput = {
    update: XOR<GrupoUpdateWithoutEscolasInput, GrupoUncheckedUpdateWithoutEscolasInput>
    create: XOR<GrupoCreateWithoutEscolasInput, GrupoUncheckedCreateWithoutEscolasInput>
    where?: GrupoWhereInput
  }

  export type GrupoUpdateToOneWithWhereWithoutEscolasInput = {
    where?: GrupoWhereInput
    data: XOR<GrupoUpdateWithoutEscolasInput, GrupoUncheckedUpdateWithoutEscolasInput>
  }

  export type GrupoUpdateWithoutEscolasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrupoUncheckedUpdateWithoutEscolasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TurmaUpsertWithWhereUniqueWithoutEscolaInput = {
    where: TurmaWhereUniqueInput
    update: XOR<TurmaUpdateWithoutEscolaInput, TurmaUncheckedUpdateWithoutEscolaInput>
    create: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput>
  }

  export type TurmaUpdateWithWhereUniqueWithoutEscolaInput = {
    where: TurmaWhereUniqueInput
    data: XOR<TurmaUpdateWithoutEscolaInput, TurmaUncheckedUpdateWithoutEscolaInput>
  }

  export type TurmaUpdateManyWithWhereWithoutEscolaInput = {
    where: TurmaScalarWhereInput
    data: XOR<TurmaUpdateManyMutationInput, TurmaUncheckedUpdateManyWithoutEscolaInput>
  }

  export type TurmaScalarWhereInput = {
    AND?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
    OR?: TurmaScalarWhereInput[]
    NOT?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
    id?: IntFilter<"Turma"> | number
    nome?: StringFilter<"Turma"> | string
    escolaId?: IntFilter<"Turma"> | number
    anoEscolarId?: IntFilter<"Turma"> | number
    criadoEm?: DateTimeFilter<"Turma"> | Date | string
    atualizadoEm?: DateTimeFilter<"Turma"> | Date | string
  }

  export type EscolaUsuarioUpsertWithWhereUniqueWithoutEscolaInput = {
    where: EscolaUsuarioWhereUniqueInput
    update: XOR<EscolaUsuarioUpdateWithoutEscolaInput, EscolaUsuarioUncheckedUpdateWithoutEscolaInput>
    create: XOR<EscolaUsuarioCreateWithoutEscolaInput, EscolaUsuarioUncheckedCreateWithoutEscolaInput>
  }

  export type EscolaUsuarioUpdateWithWhereUniqueWithoutEscolaInput = {
    where: EscolaUsuarioWhereUniqueInput
    data: XOR<EscolaUsuarioUpdateWithoutEscolaInput, EscolaUsuarioUncheckedUpdateWithoutEscolaInput>
  }

  export type EscolaUsuarioUpdateManyWithWhereWithoutEscolaInput = {
    where: EscolaUsuarioScalarWhereInput
    data: XOR<EscolaUsuarioUpdateManyMutationInput, EscolaUsuarioUncheckedUpdateManyWithoutEscolaInput>
  }

  export type EscolaCreateWithoutUsuariosInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    regiao: RegiaoCreateNestedOneWithoutEscolasInput
    grupo?: GrupoCreateNestedOneWithoutEscolasInput
    turmas?: TurmaCreateNestedManyWithoutEscolaInput
  }

  export type EscolaUncheckedCreateWithoutUsuariosInput = {
    id?: number
    nome: string
    regiaoId: number
    grupoId?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    turmas?: TurmaUncheckedCreateNestedManyWithoutEscolaInput
  }

  export type EscolaCreateOrConnectWithoutUsuariosInput = {
    where: EscolaWhereUniqueInput
    create: XOR<EscolaCreateWithoutUsuariosInput, EscolaUncheckedCreateWithoutUsuariosInput>
  }

  export type UsuarioCreateWithoutEscolasInput = {
    nome: string
    email: string
    senha: string
    tipo: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    avaliacoesAplicadas?: AvaliacaoCreateNestedManyWithoutAplicadorInput
  }

  export type UsuarioUncheckedCreateWithoutEscolasInput = {
    id?: number
    nome: string
    email: string
    senha: string
    tipo: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    avaliacoesAplicadas?: AvaliacaoUncheckedCreateNestedManyWithoutAplicadorInput
  }

  export type UsuarioCreateOrConnectWithoutEscolasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEscolasInput, UsuarioUncheckedCreateWithoutEscolasInput>
  }

  export type EscolaUpsertWithoutUsuariosInput = {
    update: XOR<EscolaUpdateWithoutUsuariosInput, EscolaUncheckedUpdateWithoutUsuariosInput>
    create: XOR<EscolaCreateWithoutUsuariosInput, EscolaUncheckedCreateWithoutUsuariosInput>
    where?: EscolaWhereInput
  }

  export type EscolaUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: EscolaWhereInput
    data: XOR<EscolaUpdateWithoutUsuariosInput, EscolaUncheckedUpdateWithoutUsuariosInput>
  }

  export type EscolaUpdateWithoutUsuariosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    regiao?: RegiaoUpdateOneRequiredWithoutEscolasNestedInput
    grupo?: GrupoUpdateOneWithoutEscolasNestedInput
    turmas?: TurmaUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiaoId?: IntFieldUpdateOperationsInput | number
    grupoId?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    turmas?: TurmaUncheckedUpdateManyWithoutEscolaNestedInput
  }

  export type UsuarioUpsertWithoutEscolasInput = {
    update: XOR<UsuarioUpdateWithoutEscolasInput, UsuarioUncheckedUpdateWithoutEscolasInput>
    create: XOR<UsuarioCreateWithoutEscolasInput, UsuarioUncheckedCreateWithoutEscolasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEscolasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEscolasInput, UsuarioUncheckedUpdateWithoutEscolasInput>
  }

  export type UsuarioUpdateWithoutEscolasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliacoesAplicadas?: AvaliacaoUpdateManyWithoutAplicadorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEscolasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliacoesAplicadas?: AvaliacaoUncheckedUpdateManyWithoutAplicadorNestedInput
  }

  export type TurmaCreateWithoutAnoEscolarInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escola: EscolaCreateNestedOneWithoutTurmasInput
    alunos?: AlunoCreateNestedManyWithoutTurmaInput
  }

  export type TurmaUncheckedCreateWithoutAnoEscolarInput = {
    id?: number
    nome: string
    escolaId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    alunos?: AlunoUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type TurmaCreateOrConnectWithoutAnoEscolarInput = {
    where: TurmaWhereUniqueInput
    create: XOR<TurmaCreateWithoutAnoEscolarInput, TurmaUncheckedCreateWithoutAnoEscolarInput>
  }

  export type TurmaCreateManyAnoEscolarInputEnvelope = {
    data: TurmaCreateManyAnoEscolarInput | TurmaCreateManyAnoEscolarInput[]
  }

  export type TurmaUpsertWithWhereUniqueWithoutAnoEscolarInput = {
    where: TurmaWhereUniqueInput
    update: XOR<TurmaUpdateWithoutAnoEscolarInput, TurmaUncheckedUpdateWithoutAnoEscolarInput>
    create: XOR<TurmaCreateWithoutAnoEscolarInput, TurmaUncheckedCreateWithoutAnoEscolarInput>
  }

  export type TurmaUpdateWithWhereUniqueWithoutAnoEscolarInput = {
    where: TurmaWhereUniqueInput
    data: XOR<TurmaUpdateWithoutAnoEscolarInput, TurmaUncheckedUpdateWithoutAnoEscolarInput>
  }

  export type TurmaUpdateManyWithWhereWithoutAnoEscolarInput = {
    where: TurmaScalarWhereInput
    data: XOR<TurmaUpdateManyMutationInput, TurmaUncheckedUpdateManyWithoutAnoEscolarInput>
  }

  export type EscolaCreateWithoutTurmasInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    regiao: RegiaoCreateNestedOneWithoutEscolasInput
    grupo?: GrupoCreateNestedOneWithoutEscolasInput
    usuarios?: EscolaUsuarioCreateNestedManyWithoutEscolaInput
  }

  export type EscolaUncheckedCreateWithoutTurmasInput = {
    id?: number
    nome: string
    regiaoId: number
    grupoId?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    usuarios?: EscolaUsuarioUncheckedCreateNestedManyWithoutEscolaInput
  }

  export type EscolaCreateOrConnectWithoutTurmasInput = {
    where: EscolaWhereUniqueInput
    create: XOR<EscolaCreateWithoutTurmasInput, EscolaUncheckedCreateWithoutTurmasInput>
  }

  export type AnoEscolarCreateWithoutTurmasInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AnoEscolarUncheckedCreateWithoutTurmasInput = {
    id?: number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AnoEscolarCreateOrConnectWithoutTurmasInput = {
    where: AnoEscolarWhereUniqueInput
    create: XOR<AnoEscolarCreateWithoutTurmasInput, AnoEscolarUncheckedCreateWithoutTurmasInput>
  }

  export type AlunoCreateWithoutTurmaInput = {
    nome: string
    dataNascimento?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    avaliacoes?: AvaliacaoCreateNestedManyWithoutAlunoInput
  }

  export type AlunoUncheckedCreateWithoutTurmaInput = {
    id?: number
    nome: string
    dataNascimento?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type AlunoCreateOrConnectWithoutTurmaInput = {
    where: AlunoWhereUniqueInput
    create: XOR<AlunoCreateWithoutTurmaInput, AlunoUncheckedCreateWithoutTurmaInput>
  }

  export type AlunoCreateManyTurmaInputEnvelope = {
    data: AlunoCreateManyTurmaInput | AlunoCreateManyTurmaInput[]
  }

  export type EscolaUpsertWithoutTurmasInput = {
    update: XOR<EscolaUpdateWithoutTurmasInput, EscolaUncheckedUpdateWithoutTurmasInput>
    create: XOR<EscolaCreateWithoutTurmasInput, EscolaUncheckedCreateWithoutTurmasInput>
    where?: EscolaWhereInput
  }

  export type EscolaUpdateToOneWithWhereWithoutTurmasInput = {
    where?: EscolaWhereInput
    data: XOR<EscolaUpdateWithoutTurmasInput, EscolaUncheckedUpdateWithoutTurmasInput>
  }

  export type EscolaUpdateWithoutTurmasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    regiao?: RegiaoUpdateOneRequiredWithoutEscolasNestedInput
    grupo?: GrupoUpdateOneWithoutEscolasNestedInput
    usuarios?: EscolaUsuarioUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaUncheckedUpdateWithoutTurmasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiaoId?: IntFieldUpdateOperationsInput | number
    grupoId?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarios?: EscolaUsuarioUncheckedUpdateManyWithoutEscolaNestedInput
  }

  export type AnoEscolarUpsertWithoutTurmasInput = {
    update: XOR<AnoEscolarUpdateWithoutTurmasInput, AnoEscolarUncheckedUpdateWithoutTurmasInput>
    create: XOR<AnoEscolarCreateWithoutTurmasInput, AnoEscolarUncheckedCreateWithoutTurmasInput>
    where?: AnoEscolarWhereInput
  }

  export type AnoEscolarUpdateToOneWithWhereWithoutTurmasInput = {
    where?: AnoEscolarWhereInput
    data: XOR<AnoEscolarUpdateWithoutTurmasInput, AnoEscolarUncheckedUpdateWithoutTurmasInput>
  }

  export type AnoEscolarUpdateWithoutTurmasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnoEscolarUncheckedUpdateWithoutTurmasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlunoUpsertWithWhereUniqueWithoutTurmaInput = {
    where: AlunoWhereUniqueInput
    update: XOR<AlunoUpdateWithoutTurmaInput, AlunoUncheckedUpdateWithoutTurmaInput>
    create: XOR<AlunoCreateWithoutTurmaInput, AlunoUncheckedCreateWithoutTurmaInput>
  }

  export type AlunoUpdateWithWhereUniqueWithoutTurmaInput = {
    where: AlunoWhereUniqueInput
    data: XOR<AlunoUpdateWithoutTurmaInput, AlunoUncheckedUpdateWithoutTurmaInput>
  }

  export type AlunoUpdateManyWithWhereWithoutTurmaInput = {
    where: AlunoScalarWhereInput
    data: XOR<AlunoUpdateManyMutationInput, AlunoUncheckedUpdateManyWithoutTurmaInput>
  }

  export type AlunoScalarWhereInput = {
    AND?: AlunoScalarWhereInput | AlunoScalarWhereInput[]
    OR?: AlunoScalarWhereInput[]
    NOT?: AlunoScalarWhereInput | AlunoScalarWhereInput[]
    id?: IntFilter<"Aluno"> | number
    nome?: StringFilter<"Aluno"> | string
    dataNascimento?: DateTimeNullableFilter<"Aluno"> | Date | string | null
    turmaId?: IntFilter<"Aluno"> | number
    criadoEm?: DateTimeFilter<"Aluno"> | Date | string
    atualizadoEm?: DateTimeFilter<"Aluno"> | Date | string
  }

  export type TurmaCreateWithoutAlunosInput = {
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escola: EscolaCreateNestedOneWithoutTurmasInput
    anoEscolar: AnoEscolarCreateNestedOneWithoutTurmasInput
  }

  export type TurmaUncheckedCreateWithoutAlunosInput = {
    id?: number
    nome: string
    escolaId: number
    anoEscolarId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TurmaCreateOrConnectWithoutAlunosInput = {
    where: TurmaWhereUniqueInput
    create: XOR<TurmaCreateWithoutAlunosInput, TurmaUncheckedCreateWithoutAlunosInput>
  }

  export type AvaliacaoCreateWithoutAlunoInput = {
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    evento: EventoAvaliacaoCreateNestedOneWithoutAvaliacoesInput
    aplicador: UsuarioCreateNestedOneWithoutAvaliacoesAplicadasInput
  }

  export type AvaliacaoUncheckedCreateWithoutAlunoInput = {
    id?: number
    eventoId: number
    aplicadorId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AvaliacaoCreateOrConnectWithoutAlunoInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutAlunoInput, AvaliacaoUncheckedCreateWithoutAlunoInput>
  }

  export type AvaliacaoCreateManyAlunoInputEnvelope = {
    data: AvaliacaoCreateManyAlunoInput | AvaliacaoCreateManyAlunoInput[]
  }

  export type TurmaUpsertWithoutAlunosInput = {
    update: XOR<TurmaUpdateWithoutAlunosInput, TurmaUncheckedUpdateWithoutAlunosInput>
    create: XOR<TurmaCreateWithoutAlunosInput, TurmaUncheckedCreateWithoutAlunosInput>
    where?: TurmaWhereInput
  }

  export type TurmaUpdateToOneWithWhereWithoutAlunosInput = {
    where?: TurmaWhereInput
    data: XOR<TurmaUpdateWithoutAlunosInput, TurmaUncheckedUpdateWithoutAlunosInput>
  }

  export type TurmaUpdateWithoutAlunosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escola?: EscolaUpdateOneRequiredWithoutTurmasNestedInput
    anoEscolar?: AnoEscolarUpdateOneRequiredWithoutTurmasNestedInput
  }

  export type TurmaUncheckedUpdateWithoutAlunosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    escolaId?: IntFieldUpdateOperationsInput | number
    anoEscolarId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutAlunoInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutAlunoInput, AvaliacaoUncheckedUpdateWithoutAlunoInput>
    create: XOR<AvaliacaoCreateWithoutAlunoInput, AvaliacaoUncheckedCreateWithoutAlunoInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutAlunoInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutAlunoInput, AvaliacaoUncheckedUpdateWithoutAlunoInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutAlunoInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutAlunoInput>
  }

  export type AvaliacaoCreateWithoutEventoInput = {
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    aluno: AlunoCreateNestedOneWithoutAvaliacoesInput
    aplicador: UsuarioCreateNestedOneWithoutAvaliacoesAplicadasInput
  }

  export type AvaliacaoUncheckedCreateWithoutEventoInput = {
    id?: number
    alunoId: number
    aplicadorId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AvaliacaoCreateOrConnectWithoutEventoInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutEventoInput, AvaliacaoUncheckedCreateWithoutEventoInput>
  }

  export type AvaliacaoCreateManyEventoInputEnvelope = {
    data: AvaliacaoCreateManyEventoInput | AvaliacaoCreateManyEventoInput[]
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutEventoInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutEventoInput, AvaliacaoUncheckedUpdateWithoutEventoInput>
    create: XOR<AvaliacaoCreateWithoutEventoInput, AvaliacaoUncheckedCreateWithoutEventoInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutEventoInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutEventoInput, AvaliacaoUncheckedUpdateWithoutEventoInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutEventoInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutEventoInput>
  }

  export type AlunoCreateWithoutAvaliacoesInput = {
    nome: string
    dataNascimento?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    turma: TurmaCreateNestedOneWithoutAlunosInput
  }

  export type AlunoUncheckedCreateWithoutAvaliacoesInput = {
    id?: number
    nome: string
    dataNascimento?: Date | string | null
    turmaId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AlunoCreateOrConnectWithoutAvaliacoesInput = {
    where: AlunoWhereUniqueInput
    create: XOR<AlunoCreateWithoutAvaliacoesInput, AlunoUncheckedCreateWithoutAvaliacoesInput>
  }

  export type EventoAvaliacaoCreateWithoutAvaliacoesInput = {
    nome: string
    dataInicio: Date | string
    dataFim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type EventoAvaliacaoUncheckedCreateWithoutAvaliacoesInput = {
    id?: number
    nome: string
    dataInicio: Date | string
    dataFim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type EventoAvaliacaoCreateOrConnectWithoutAvaliacoesInput = {
    where: EventoAvaliacaoWhereUniqueInput
    create: XOR<EventoAvaliacaoCreateWithoutAvaliacoesInput, EventoAvaliacaoUncheckedCreateWithoutAvaliacoesInput>
  }

  export type UsuarioCreateWithoutAvaliacoesAplicadasInput = {
    nome: string
    email: string
    senha: string
    tipo: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escolas?: EscolaUsuarioCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutAvaliacoesAplicadasInput = {
    id?: number
    nome: string
    email: string
    senha: string
    tipo: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    escolas?: EscolaUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutAvaliacoesAplicadasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAvaliacoesAplicadasInput, UsuarioUncheckedCreateWithoutAvaliacoesAplicadasInput>
  }

  export type AlunoUpsertWithoutAvaliacoesInput = {
    update: XOR<AlunoUpdateWithoutAvaliacoesInput, AlunoUncheckedUpdateWithoutAvaliacoesInput>
    create: XOR<AlunoCreateWithoutAvaliacoesInput, AlunoUncheckedCreateWithoutAvaliacoesInput>
    where?: AlunoWhereInput
  }

  export type AlunoUpdateToOneWithWhereWithoutAvaliacoesInput = {
    where?: AlunoWhereInput
    data: XOR<AlunoUpdateWithoutAvaliacoesInput, AlunoUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type AlunoUpdateWithoutAvaliacoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    turma?: TurmaUpdateOneRequiredWithoutAlunosNestedInput
  }

  export type AlunoUncheckedUpdateWithoutAvaliacoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turmaId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoAvaliacaoUpsertWithoutAvaliacoesInput = {
    update: XOR<EventoAvaliacaoUpdateWithoutAvaliacoesInput, EventoAvaliacaoUncheckedUpdateWithoutAvaliacoesInput>
    create: XOR<EventoAvaliacaoCreateWithoutAvaliacoesInput, EventoAvaliacaoUncheckedCreateWithoutAvaliacoesInput>
    where?: EventoAvaliacaoWhereInput
  }

  export type EventoAvaliacaoUpdateToOneWithWhereWithoutAvaliacoesInput = {
    where?: EventoAvaliacaoWhereInput
    data: XOR<EventoAvaliacaoUpdateWithoutAvaliacoesInput, EventoAvaliacaoUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type EventoAvaliacaoUpdateWithoutAvaliacoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoAvaliacaoUncheckedUpdateWithoutAvaliacoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUpsertWithoutAvaliacoesAplicadasInput = {
    update: XOR<UsuarioUpdateWithoutAvaliacoesAplicadasInput, UsuarioUncheckedUpdateWithoutAvaliacoesAplicadasInput>
    create: XOR<UsuarioCreateWithoutAvaliacoesAplicadasInput, UsuarioUncheckedCreateWithoutAvaliacoesAplicadasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutAvaliacoesAplicadasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutAvaliacoesAplicadasInput, UsuarioUncheckedUpdateWithoutAvaliacoesAplicadasInput>
  }

  export type UsuarioUpdateWithoutAvaliacoesAplicadasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escolas?: EscolaUsuarioUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAvaliacoesAplicadasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escolas?: EscolaUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type EscolaUsuarioCreateManyUsuarioInput = {
    id?: number
    escolaId: number
    criadoEm?: Date | string
  }

  export type AvaliacaoCreateManyAplicadorInput = {
    id?: number
    alunoId: number
    eventoId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type EscolaUsuarioUpdateWithoutUsuarioInput = {
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escola?: EscolaUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type EscolaUsuarioUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    escolaId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaUsuarioUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    escolaId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUpdateWithoutAplicadorInput = {
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    aluno?: AlunoUpdateOneRequiredWithoutAvaliacoesNestedInput
    evento?: EventoAvaliacaoUpdateOneRequiredWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutAplicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    alunoId?: IntFieldUpdateOperationsInput | number
    eventoId?: IntFieldUpdateOperationsInput | number
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUncheckedUpdateManyWithoutAplicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    alunoId?: IntFieldUpdateOperationsInput | number
    eventoId?: IntFieldUpdateOperationsInput | number
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaCreateManyRegiaoInput = {
    id?: number
    nome: string
    grupoId?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type EscolaUpdateWithoutRegiaoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    grupo?: GrupoUpdateOneWithoutEscolasNestedInput
    turmas?: TurmaUpdateManyWithoutEscolaNestedInput
    usuarios?: EscolaUsuarioUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaUncheckedUpdateWithoutRegiaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    grupoId?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    turmas?: TurmaUncheckedUpdateManyWithoutEscolaNestedInput
    usuarios?: EscolaUsuarioUncheckedUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaUncheckedUpdateManyWithoutRegiaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    grupoId?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaCreateManyGrupoInput = {
    id?: number
    nome: string
    regiaoId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type EscolaUpdateWithoutGrupoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    regiao?: RegiaoUpdateOneRequiredWithoutEscolasNestedInput
    turmas?: TurmaUpdateManyWithoutEscolaNestedInput
    usuarios?: EscolaUsuarioUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaUncheckedUpdateWithoutGrupoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiaoId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    turmas?: TurmaUncheckedUpdateManyWithoutEscolaNestedInput
    usuarios?: EscolaUsuarioUncheckedUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaUncheckedUpdateManyWithoutGrupoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiaoId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TurmaCreateManyEscolaInput = {
    id?: number
    nome: string
    anoEscolarId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type EscolaUsuarioCreateManyEscolaInput = {
    id?: number
    usuarioId: number
    criadoEm?: Date | string
  }

  export type TurmaUpdateWithoutEscolaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    anoEscolar?: AnoEscolarUpdateOneRequiredWithoutTurmasNestedInput
    alunos?: AlunoUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaUncheckedUpdateWithoutEscolaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    anoEscolarId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    alunos?: AlunoUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaUncheckedUpdateManyWithoutEscolaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    anoEscolarId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaUsuarioUpdateWithoutEscolaInput = {
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEscolasNestedInput
  }

  export type EscolaUsuarioUncheckedUpdateWithoutEscolaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscolaUsuarioUncheckedUpdateManyWithoutEscolaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TurmaCreateManyAnoEscolarInput = {
    id?: number
    nome: string
    escolaId: number
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TurmaUpdateWithoutAnoEscolarInput = {
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    escola?: EscolaUpdateOneRequiredWithoutTurmasNestedInput
    alunos?: AlunoUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaUncheckedUpdateWithoutAnoEscolarInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    escolaId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    alunos?: AlunoUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaUncheckedUpdateManyWithoutAnoEscolarInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    escolaId?: IntFieldUpdateOperationsInput | number
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlunoCreateManyTurmaInput = {
    id?: number
    nome: string
    dataNascimento?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AlunoUpdateWithoutTurmaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliacoes?: AvaliacaoUpdateManyWithoutAlunoNestedInput
  }

  export type AlunoUncheckedUpdateWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type AlunoUncheckedUpdateManyWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoCreateManyAlunoInput = {
    id?: number
    eventoId: number
    aplicadorId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AvaliacaoUpdateWithoutAlunoInput = {
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    evento?: EventoAvaliacaoUpdateOneRequiredWithoutAvaliacoesNestedInput
    aplicador?: UsuarioUpdateOneRequiredWithoutAvaliacoesAplicadasNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventoId?: IntFieldUpdateOperationsInput | number
    aplicadorId?: IntFieldUpdateOperationsInput | number
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUncheckedUpdateManyWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventoId?: IntFieldUpdateOperationsInput | number
    aplicadorId?: IntFieldUpdateOperationsInput | number
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoCreateManyEventoInput = {
    id?: number
    alunoId: number
    aplicadorId: number
    palavrasPorMinuto: number
    precisao: number
    fluencia: number
    compreensao: number
    nivelLeitura: string
    observacoes?: string | null
    dataAvaliacao: Date | string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AvaliacaoUpdateWithoutEventoInput = {
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    aluno?: AlunoUpdateOneRequiredWithoutAvaliacoesNestedInput
    aplicador?: UsuarioUpdateOneRequiredWithoutAvaliacoesAplicadasNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutEventoInput = {
    id?: IntFieldUpdateOperationsInput | number
    alunoId?: IntFieldUpdateOperationsInput | number
    aplicadorId?: IntFieldUpdateOperationsInput | number
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUncheckedUpdateManyWithoutEventoInput = {
    id?: IntFieldUpdateOperationsInput | number
    alunoId?: IntFieldUpdateOperationsInput | number
    aplicadorId?: IntFieldUpdateOperationsInput | number
    palavrasPorMinuto?: IntFieldUpdateOperationsInput | number
    precisao?: FloatFieldUpdateOperationsInput | number
    fluencia?: FloatFieldUpdateOperationsInput | number
    compreensao?: FloatFieldUpdateOperationsInput | number
    nivelLeitura?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegiaoCountOutputTypeDefaultArgs instead
     */
    export type RegiaoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegiaoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GrupoCountOutputTypeDefaultArgs instead
     */
    export type GrupoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GrupoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscolaCountOutputTypeDefaultArgs instead
     */
    export type EscolaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscolaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnoEscolarCountOutputTypeDefaultArgs instead
     */
    export type AnoEscolarCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnoEscolarCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TurmaCountOutputTypeDefaultArgs instead
     */
    export type TurmaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TurmaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlunoCountOutputTypeDefaultArgs instead
     */
    export type AlunoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlunoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventoAvaliacaoCountOutputTypeDefaultArgs instead
     */
    export type EventoAvaliacaoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventoAvaliacaoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegiaoDefaultArgs instead
     */
    export type RegiaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegiaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GrupoDefaultArgs instead
     */
    export type GrupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GrupoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscolaDefaultArgs instead
     */
    export type EscolaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscolaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscolaUsuarioDefaultArgs instead
     */
    export type EscolaUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EscolaUsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnoEscolarDefaultArgs instead
     */
    export type AnoEscolarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnoEscolarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TurmaDefaultArgs instead
     */
    export type TurmaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TurmaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlunoDefaultArgs instead
     */
    export type AlunoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlunoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventoAvaliacaoDefaultArgs instead
     */
    export type EventoAvaliacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventoAvaliacaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AvaliacaoDefaultArgs instead
     */
    export type AvaliacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AvaliacaoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}